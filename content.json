{"pages":[],"posts":[{"title":"数组常用方法，掌握这些就够了","text":"数组遍历的一些方法1、forEach方法1234567891011121314forEach((item, index, self) =&gt;{ //数组处理代码 }) /*对数组进行遍历，对数组中的每一个成员执行 回调函数中的代码可以对数组中的成员 进行筛选，也可以对每一个成员进行一些操作，没有返回值 参数： item：数组遍历的当前成员（非必须参数） index：数组当前项的索引（非必须参数） sele：数组本身（非必须参数）*/ var arr = [1, 2, 3] arr.forEach((item, index, arrself) =&gt;{ console.log(item, index, arrself) }) 2、filter方法1234567891011filter((item, index, self) =&gt;{ //数组处理代码 }) /*对数组进行过滤，对数组中的每一个成员执行 回调函数中的代码可以对数组中的成员 进行筛选，返回一个满足条件的新数组*/ var arr = [11, 20, 35, 3, 15] var res = arr.filter((item, index, arrself) =&gt;{ return item &gt;= 15 }) console.log(res) //返回数组[20, 35, 15] 3、map方法1234567891011map((item, index, self) =&gt;{ //数组处理代码 }) /*对数组进行映射，对数组中的每一个成员执行 回调函数中的代码，返回一个满足条件 的新数组，常用于把数组中每一项成员执行相同操作*/ var arr = [1, 2, 3] var res = arr.map((item, index, arrself) =&gt;{ return item * 2 }) console.log(res) //返回数组[2, 4, 6] 4、some方法和every方法123456789101112131415161718192021222324some((item, index, self) =&gt;{ //数组处理代码 })every((item, index, self) =&gt;{ //数组处理代码 }) /*两种方法都是对数组进行遍历，对数组中的每一个成员执行 回调函数中的代码，返回 一个布尔值，常用于判断数组中成员是否满足条件不同点： some方法在遍历数组时，只要有一个成员满足条件即停止遍历返回true every方法在遍历数组时，需要所有成员满足条件才会返回true注意： 可以利用some只要有满足条件即会停止查找的机制优化代码执行效率*/ var arr = [1, 2, 3] var res1 = arr.some((item, index, arrself) =&gt;{ return item &gt; 2 }) console.log(res1) //返回布尔值true var res2 = arr.every((item, index, arrself) =&gt;{ return item &gt; 2 }) console.log(res2) //返回布尔值false 5、find方法和findIndex方法12345678910111213141516171819202122find((item, index, self) =&gt;{ //数组处理代码 })findIndex((item, index, self) =&gt;{ //数组处理代码 }) /*对数组进行遍历查找，对数组中的每一个成员执行回 调函数中的代码，常用于查找数 组中成员的筛选，只要有满足条件的就会停止查找不同点： find方法会返回满足条件的成员，没有满足的返回undefined findIndex方法会返回满足条件成员的索引，没有满足的返回undefined */ var arr = [1, 9, 3, 6, 5] var res1 = arr.find((item, index, arrself) = &gt;{ return item &gt; 5 }) console.log(res1) //返回9 var res2 = arr.findIndex((item, index, arrself) = &gt;{ return item &gt; 5 }) console.log(res2) //返回1 6、indexOf方法和lastIndexOf方法123456789101112131415161718192021indexOf(value, position)lastIndexOf(value, position) /*对数组进行遍历查找，常用于查找数组中指定选项的索引，返回索引值，如果数组中 没有要查找的选项返回-1参数： value:要查找的选项 position:查找的起始索引位置（非必须选项）不同点： indexOf方法从前往后依次查找 lastIndexOf方法从后往前一次查找注意： 可以利用返回-1的特性判断数组是否包含要查找的选项*/ var arr = [1, 9, 3, 6, 5] var res1 = arr.indexOf(9) console.log(res1) //返回1 var res2 = arr.lastIndexOf(9) console.log(res2) //返回1 var res3 = arr.indexOf(2) console.log(res3) //返回-1 6、includes方法1234567includes(value) /*对数组进行遍历查找，查找数组中是否包含要查找的选项，返回一个布尔值参数： value:要查找的选项*/ var arr = [1, 9, 3, 6, 5] var res = arr.includes(9) console.log(res) //返回true 数组处理的一些方法1、join方法1234567join(分隔符) /*对数组中每一项用分隔符进行拼接，返回一个字符串参数： 分隔符:数组以什么字符进行拼接*/ var arr = [1, 9, 3, 6, 5] var res = arr.join(\"$\") console.log(res) //返回字符串\"1$9$3$6$5\" 2、concat方法123456789concat(options) /*对数组进行参数的拼接，常用于把其他数组和操作数组拼接在一起，返回一个新数组参数： options:数组要拼接的参数（可以是字符串，也可以是数组）*/ var arr = [1, 5] var str = \"你好\" var arrNew = [3, 6] var res = arr.concat(str, arrNew) console.log(res) //返回数组[1, 5, \"你好\", 3, 6] 3、push方法和pop方法123456789101112push(options) //对数组进行添加成员，常用于把其他参数添加到数组`后`面，返回修改后数组长度pop() /*对数组成员进行删除，常用于把数组`最后一项`移出，返回被移除的成员参数： options:添加数组的成员*/ var arr = [1, 5] var res1 = arr.push(3, 7) console.log(res1) //返回数组长度4 var res2 = arr.pop() console.log(res2) //返回被删除成员7 4、unshift方法和shift方法123456789101112unshift(options) //对数组进行添加成员，常用于把其他参数添加到数组`前`面，返回修改后数组长度shift() /*对数组成员进行删除，常用于把数组`第一项`移出，返回被移除的成员，空数组返回undefined参数： options:添加数组的成员*/ var arr = [1, 5] var res1 = arr.unshift(3, 7) console.log(res1) //返回数组长度4 var res2 = arr.shift() console.log(res2) //返回被删除成员3 5、slice方法1234567891011slice(start, end) /*对数组进行截取，常用于截取数组中的一段数据，返回一个新数组参数： start:截取的开始位置 end:截取的结束位置（非必须参数）注意： 只设置一个参数测从开始位置截取到数组结束，默认第二个参数变成数组长度 设置两个参数时位置包左不包右，会截取到结束位置前一个成员*/ var arr = [1, 5, 3, 7, 10, 21, 6] var res = arr.slice(2, 4) console.log(res) //返回数组[3, 7, 10] 6、splice方法(一个非常非常好用的数组处理方法)1234567891011splice(start, count, value) /*对数组进行截取，常用于截取数组中的数据，插入数据，返回被删除选项组成的新数 组，如果没有删除选项则返回空数组，非常强大的方法，操作原数组参数： start:截取的开始位置（必须参数） count:截取的成员数（必须参数） value:要插入数组的成员（非必须参数）*/ var arr = [1, 5, 3, 7, 10, 21, 6] var res = arr.splice(2, 1, \"插入数据\") console.log(res) //返回数组[3] console.log(arr) //[1, 5, \"插入数据\", 7, 10, 21, 6] 数组中的其他方法1、reverse方法12345reverse() //对数组进行翻转，用来改变数组中成员的顺序 var arr = [1, 9, 3, 6, 5] arr.reverse() console.log(arr) //[5, 6, 3, 9, 1] 2、flat方法12345678910flat(value) /*对多维数组进行铺平展开，常用于数组中成员依然为数组的数组进行展开变成一维数 组，返回一个新数组参数： value:要展开数组得维数注意： 在一般情况下我们不知道要展开数组的维数，可设置为infinite */ var arr = [1, 9, [7, 8, 10], 6, 5] var res = arr.flat(infinite) console.log(res) //返回一维数组[1, 9, 7, 8, 10, 6, 5]","link":"/2017/12/15/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%8C%E6%8F%A1%E8%BF%99%E4%BA%9B%E5%B0%B1%E5%A4%9F%E4%BA%86/"},{"title":"关于小程序开发的总结","text":"1、navigationBar在哪配置？配置了个啥？ app.json中配置；顶部栏（背景色、名字、名字） 2、tabBar是什么？/ list字段中每一项都是什么？ tab栏；（导航栏，项：设置每一个功能） ist字段：配置每一项； text：选项文字 iconPath：图标路径，相对路径 selectedIconPath: 当前选择项的图标路径 pagePath：选项卡点击后的页面地址； 3、如何理解小程序rpx单位？实际开发中有什么要求？ rpx：不同的手机屏幕下，代表的px值；自动识别手机的； 要求：UI给我们的页面750px的设计稿，然后写页面 测量360px，在小程序里面写360rpx; 4、小程序预览需要设置什么？ 图片，打包后超过2M 本地图片：开始的时候帮助我们搭建静态页； 地址： 项目中图片，字体文件，后台请求回来的网络地址； tabBar图片不能上传；本地地址支持； 预览：设置一个忽略！ **打包的设置：packOptions：打包设置 ignore：忽略打包编译项目： 文档 找到：packOptions /ignore 5、如何设置为体验版本？ 为什么设置体验版？ 开发人员 测试人员； 测试人员：看到我们现在写的项目； 成员管理：体验成员管理； 代码: 上传到微信小程序后台管理平台； 版本管理：设置为体验版本！ 6、小程序V2样式有什么问题么？ 问题： 按钮：默认宽度； 自己设置又设置了一个宽度； 发现： 现在自己定义这个宽度在调试窗口已经生效；原来的默认宽度被覆盖！ 在显示界面：宽度还是 默认宽度； CSS权重问题！ 思考: 忘记不使用v2 发现你的布局样式有问题，是不是V2问题？ 7、小程序wx:for=&quot;item in list&quot;这样对么？设置唯一标示如何设置？ vue写法：v-for=&quot;item in list&quot; 正确：1wx:for={{list}} //注意{{}} 唯一标示： 用数据的index,ID wx:key=&quot;*this&quot;：找不到唯一标示； 8、多个标签被同时循环或者被判断if ，应该如何设置？ wx:if 组件：&lt; block &gt; 被同时循环或者被判断if的组件，包起来！ 在block上写wx语法； 9、原生小程序的事件回调函数可以传入参数么？如何设置获取组件上自定义属性？ 不能传入参数：语法设置不能传入； 自定义数据： 如何设置：data-xxxx 获取：事件执行的回调，需要事件对象；e.target.dataset获取自定义属性的（键值对） 意思：相当于是我们给组件通过另外的形式传入 参数 10、小程序更新数据，使用哪个方法？ this.setData({要更新的数据}) 11、请求是哪个方法？上线后如何配置？本地开发时如何配置？ wx.request(); 平台：配置 request合法域名请求 本地开发：IDE测试的时候 12、事件执行的三个阶段？为什么要阻止冒泡？ 事件执行三个阶段：捕获、达到目标、冒泡阶段； 事件默认是在冒泡阶段执行； 不阻止： 子组件注册了tap事件 父级注册了tap事件 当我们触发子级，父级也会跟着触发； 用户知道自己点对了：点的就是子级 父级跟着触发的这个情况：给用户体验不好，阻止冒泡！ 13、小程序场景值：打开方式有什么用处？小程序场景值在哪获取？ 打开方式：扫一扫、搜索、转发；哪种统计次数更多的话，调整公司策略； onLaunch() : 事件对象获取场景值； 打开方式业务在onLaunch写；单独写函数；在onLaunch调用； 14、页面地址的参数如何传递？如何获取？ 小程序有很多页面； ugo：分类商品。点击每个商品的时候，进入一个详情页（同一个页面，不同的数据）； 传递：pages/detail/index?name=zs&amp;age=18 获取： 页面onLoad(e){}事件对象可以获取 页面传递的参数； 接下来：请求数据，返回这个查询的数据，渲染； 15、小程序 模块化有几种方式？ 第三方包：npm包；用别人写好的东西； 入口主文件 app.js 其他页面使用：getApp()推荐！ app.js 里面写什么： 在任何页面的JS中使用： 16、小程序npm模块如何配置和使用？ 第三方包：npm包；用别人写好的东西； 封装比较好，功能丰富！ 项目的目录下： npm init --yes npm i xxx -S 点击 微信开发工具 / 工具 / 构建npm 详情 / 本地设置**：使用npm模块 测试： 了解：小程序寻找包的规则：在JS页面中使用require 优先：寻找miniprogram_npm下的包 如果没有，则找当前路径下，有没有这个名字的JS文件 如果没有，则页面报错找不到； 17、wxs在渲染层起到什么作用？ 小程序： 渲染层 + JS逻辑层: 没有直接的关联； 需求：页面数据 返回的 时间戳 ；需要转换为 时间格式 JS逻辑层：处理时间戳，有可能会改变源数据； 想要：时间格式能显示，又不改变源数据！ 渲染层：wxml wxss wxs:(可以理解微信自己的特有的为HTML CSS JS ) 代码: 执行函数(time) 如果执行函数是真实页面下JS内一个方法；就不会生效！ 自定义函数可以设置为 wxs下的一个方法：就可以使用 思考：wxs当做：vue中常说 filter 过滤器； 18、通信的思考：数据共享!!! 组件： 父子组件！ 组件之间如何通信？ 子组件：设置自定义属性： 自己笔记：理解写下来！ 思考： 兄弟组件之间如何通信？getApp(); 背后：为了共享一些数据： vue:共享数据； eventbus 找个自己写的公共的JS文件； localStorage 新的语法： 语法，思考语法能帮助实现啥？ 写例子：todoList(增 删 改 查) http://www.todolist.cn/ 19、通信：父给子传递数据，子组件需要设置什么？ 子级：接受数据，设置属性： 20、组件通信：子给父传递数据，子组件需要设置什么？ 理解：子组件自定义事件名称，及要发送数据； 语法： 21、表单：如何获取输入框的数据？如何获取单/多选择框的数据？!!! 表单输入类： form： form本身 绑定事件submit事件 form 下面按钮：form-type 获取表单数据： input 组件 name属性 在submit回调函数 的事件 对象里获取；ev.detail.value 单/多选择： 单/多选择组 （组件）绑定 change 事件 change 事件回调函数 拿到单多选的数据； 拿到数据通过 this.setData（）设置到初始化数据中 在form 的submit 事件的回调函数内可以拿到数据: 22、ugo主页搜索组件覆盖整个页面，主页页面的滚动条，如何解决没有滚动条？ 问题： 搜索是按照一个组件的形式；页面中一个标签！ 布局：把整个页面覆盖住，主页上组件大多了；会出现滚动条！ 解决过程： 搜索组件处于聚焦状态的时候， 获取下窗口显示的高度， 通过父子组件通信：把获取的高度传递回去； 父级页面中可以获取高度H！ 设置页面高pageH度为 H；样式上：设置溢出隐藏！ 其他思路： 主页上搜索的地方放入组件input；注册事件；点击； 触发事件后：转跳另外一个页面； 可以规避滚动条问题！ 体验不如上一个：转跳的时候会有短暂的白页面！ 23、下拉刷新需要配置么，接下来的业务是什么，如何实现？ 配置： 需要配置； 原生：index.json uni: pages.json 在哪？订单页，支付页，商品分类页！！页面下JSON文件；每一个小程序页面也可以使用 .json 文件1enablePullDownRefresh:true 开启：效果！！！ 业务： 用户：下拉是个行为； 函数：响应这个行为；生命周期（函数）！123Page({ onPullDownRefresh(){ 所有数据进行重新请求一次}}) 请求：异步 uni-app：async await; 原生开发：所有的异步都完成后，结束下拉效果； 封装promise； promise.all[].then(function(结束下拉效果)) 24、多次触底多次加载，如何解决这个问题？ 解决1： 解决2： 请求插件封装！ 优化：loading层加载（api：设置mask 遮罩！透明黑色层，用户防止用户再次触发屏幕！) 25、什么是区域滚动和页面滚动？区域滚动的应用场景有哪些？ 小程序：页面滚动 区域滚动：组件内可以形成一个滚动；特有的组件 通过css：overflow属性，bug：当你滑动屏幕的时候，不知道大家要让哪个部分滑动； 区域滚动的应用场景有哪些？ 横向很长导航栏； ugo：搜索确认栏布局 26、路由：转跳到非tabBar页的方式有哪几种？转跳到tabBar页的方式有哪几种？ 转跳到 非tabBar 组件：&lt;navigator url=&quot;/pages/goods/index&quot;&gt; JS：123wx.navigateTo({ url:\"/pages/goods/index\"}) 转跳到 tabBar 组件：&lt;navigator url=&quot;/pages/goods/index&quot; open-type=&quot;switchTab&quot;&gt; JS：123wx.switchTab({ url:&quot;/pages/goods/index&quot;}); 回到上一页：wx.navigateBack() 27、小程序的页面默认支持转发么？如何配置自定义转发？ 页面：广告页！订单页，个人用户信息页！默认不支持； 开启： 配置：uni.showShareMenu(); 只是开启，不是自定义；（低配版） 自定义转化：默认转发的时候，样子太丑，用户不敢点击，页面的一个生命周期函数；需要返回一个对象，包括下面：（美化版） 转化的标题 图片（经过设计的图片） 链接地址；12345678onShareAppMessage () { return { title: '欢迎使用UGO!', imageUrl: 'http://www.999zx.cn/adm_file/fck /images/2018/4/Image/20184386447866.jpg', path: '/pages/index/index' }} 28、获取用户隐私信息使用哪个组件和属性设置？获取非隐私信息使用哪个组件？ 用户隐私：需要让用户自己点； &lt;button open-type&gt; 非隐私信息：头像，昵称，性别，国际，语言！type有属性值： 29、ugo购物车结算前，需要做什么验证？ 三个验证： 收货地址： 结算商品： token：当前谁要买这个商品的这个用户 ，标识加密字符串的标识； 没有token：token获取流程；用户登录获取token的整个流程？ code ： 为了安全！ 如果token泄露了，其他人拿到 A君的token ，结算！ 有个平台小额免密支付：用该用户的A君 token 支付； 30、组件web-view有啥作用？ web-view：src：引入外面域名地址； 可以通过小程序直接内引入 已经写好的HTML5移动端页面； 个人不支持：web-view 好处：应急！HTML5网页； 开发的时候：配置 31、什么是微信网页？有什么特别的地方？ 面试：公众号开发！前端！ 微信网页：HTNL CSS JS移动端页面 特别的地方： 没有什么特别地方：本身来说，就是HTML页面放入公众号了； 特别地方： 放入公众号，可以用一些微信特别的功能；JS-SDK 拍照、录音等！ 思路： 过去：没有小程序，网页有些特别的功能，JS-SDK JS包； 现在：小程序，提供了非常丰富的API； 32、使用JS-SDK的获取验证的整个流程？（从前到后） 验证：12345678910wx.config({ debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert // 出来，若要查看传入的参数，可以在pc端打开，参数信 // 息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表}); 使用：123wx.ready(function(){}) 33、{&quot;errMsg&quot;chooselmage:fail, permission value is offline verifying&quot;} 这个报错是什么意思？ 用的这个API方法没有登记； 在哪登记？ config方法下面 jsApiList ：[“chooselmage”] 34、WeUI是什么？可以在非微信网页使用么？ CSS样式库；微信团队已经写好的CSS样式； 非微信网页使用：当然可以！！！ 移动端：样式像微信；WeUI","link":"/2018/02/27/%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%BB%E7%BB%93/"},{"title":"Vue移动端项目总结","text":"Vue移动项目总结项目初始化使用Vue-cli创建项目1、安装脚手架 npm install @vue/cli 2、创建项目 vue create 项目名称 3、配置项目 对项目初始化进行一些配置 Vue CLI v4.1.2 ? Please pick a preset: default (babel, eslint) &gt; Manually select features 选择第2种：手动选择特性，支持更多自定义选项 分别选择： Babel：es6 转 es5 Router：路由 Vuex：数据容器，存储共享数据 CSS Pre-processors：CSS 预处理器，后面会提示你选择less、sass、stylus等Linter/Formatter：代码格式校验 4、进入项目目录 cd 项目名称 5、启动服务 npm run serve(dev还是serve看配置)初始目录结构说明├── .browserslistrc ├── .editorconfig ├── .eslintrc.js ├── .gitignore ├── README.md ├── babel.config.js ├── package-lock.json ├── package.json ├── public │ ├── favicon.ico │ └── index.html └── src ├── App.vue 根组件 ├── assets 资源目录 ├── components 公共组件 ├── main.js 入口模块 ├── router 路由 ├── store Vuex容器 └── views 路由组件代码的管理Git正常的话我们需要创建 Git 仓库并提交历史记录。 123git initgit add 文件git commit\"提交日志\" 但是Vue-cli 在生成项目的时候默认完成了Git仓库的初始化和初始提交，所以这里只需要push到线上即可。 12git remote add 你的远程仓库地址git push -u origin master 之后如果需要提交，则还是常规的add、commit、push。 123git add 文件git commit -m \"提交日志\"git push组件库导入（Vant组件库）这里建议为了前期开发的便利性先一次性导入所有 Vant 组件，在最后做打包优化的时候配置按需加载以降低打包体积大小 1、安装 Vant 1npm i vant -S 2、在main.js中加载注册Vant组件（注意要引入Vant样式文件） 123456// 全局引入（体积包比较大）import Vant from 'vant'import 'vant/lib/index.css' Vue.use(Vant)// 引入vant组件,这里我们动态加载（推荐）import './utils/register-vant' 3、按需加载组件 在utils中新建Vant组件加载文件vant-register.js 1234567import Vue from 'vue'// 引入组件import { Button, Cell, CellGroup} from 'vant'// 全剧注册组件Vue.use(Button).use(Cell).use(CellGroup)样式处理1、样式初始化组件包 Normalize.css只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案Normalize.css现在已经被用于Twitter Bootstrap以及许许多多其他框架、工具和网站上 1、安装 1npm i normalize.css 2、在main.js中引入 1import 'normalize.css' 但是我们的项目不需要加载它,不是不需要，因为我们使用了第三方组件库Vant,它内置了normalize.css，所以我们不需要自己手动安装配置它了。 2、配置Rem适配 Vant中的样式默认使用`px`作为单位，如果需要使用rem单位推荐使用两个工具 postcss-pxtorem:用于将单位转化为rem amfe-flexible:用于设置rem基准值 使用amfe-flexible动态设置 REM 基准值（html 标签的字体大小） 1、安装 1npm i amfe-flexible 2、然后在 `main.js` 中加载执行该模块 1import 'amfe-flexible' 使用postcss-pxtorem将 px 转为 rem 1、安装 1npm install postcss-pxtorem -D 2、然后在**项目根目录**中创建`postcss.config.js`文件 1234567891011module.exports = { plugins: { \"postcss-pxtorem\": { // 设计稿 375:37.5 // 设计稿：750:75 // Vant 是基于 375 rootValue: 37.5, propList: [\"*\"] } }} 3、**配置完毕，重新启动服务**项目中axios配置1、安装axios 1npm i axios 2、创建src/utils/request.js 1234567import axios from \"axios\"// axios.create 方法：复制一个axios,可以直接配置基础路径const request = axios.create({ baseURL: \"请求基础路径\"})// 最后导出我们复制的requestexport default request 3、如何使用 把每一个请求都封装成一个的独立功能函数，在独立的功能函数中导出请求方法，在需要的时候加载调用即可 1234567import request from '@/utils/request.js'export const getData = () =&gt; { return request({ url: '', method: 'GET' })} 4、axios中的请求、响应拦截问题(包含处理token问题) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 设置请求拦截request.interceptors.request.use(config =&gt; { const user = store.state.user if (user) { config.headers.Authorization = `Bearer ${user.token}` } return config}, error =&gt; { return Promise.reject(error)})// 设置响应拦截request.interceptors.response.use(function (response) { return response}, async function (error) { // 判断是否是401 if (error.response &amp;&amp; error.response.status === 401) { const user = store.state.user // 判断是否有refresh_token if (!user || !user.refresh_token) { // 没有refresh_token直接跳转登录 reLogin() return } try { // 有refresh_token重新获取token const { data } = await axios({ url: 'http://ttapi.research.itcast.cn/app/v1_0/authorizations', method: 'PUT', headers: { Authorization: `Bearer ${user.refresh_token}` } }) // 重新赋值token store.commit('setUser', { ...user, token: data.data.token }) // 继续之前的请求 return request(error.config) } catch (err) { console.log('请求刷新失败', err) reLogin() } } return Promise.reject(error)})function reLogin () { router.push({ name: 'Login', query: { redirect: router.currentRoute.fullPath } })}项目中路由表的配置1、配置路由表 123456789101112131415161718import Vue from 'vue'import VueRouter from 'vue-router'// 在全局注册路由Vue.use(VueRouter)// 实例化路由对象const router = new VueRouter({ routes})// 配置路由规则const routes = [ { path: '/login', name: 'Login', component: () =&gt; import('@/views/login') }]// 导出路由export default router 2、在main.js中引入路由并注册路由 123456import router from './router'new Vue({ router, store, render: h =&gt; h(App)}).$mount('#app')表单验证问题（vee-validate插件）https://logaretm.github.io/vee-validate/1、安装 1npm i vee-validate 1234567891011121314151617182、创建 `utils/validation.js`import Vue from 'vue'// 加载需要使用的验证组件import { ValidationProvider, ValidationObserver, extend } from 'vee-validate'// 加载内置的验证规则import * as rules from 'vee-validate/dist/rules'// 加载中文语言包import { messages } from 'vee-validate/dist/locale/zh_CN.json'// 注册全局组件Vue.component('ValidationProvider', ValidationProvider)Vue.component('ValidationObserver', ValidationObserver)// 配置验证规则和中文提示Object.keys(rules).forEach(rule =&gt; { extend(rule, { ...rules[rule], message: messages[rule] })}) 3、在main.js加载执行 1import './utils/validation.js' 4、基本使用（使用内置验证规则或自定义验证规则） 使用ValidationObserver把需要校验的整个表单包起来 使用ValidationProvider把需要校验的具体表单元素包起来，例如 input 通过ValidationProvider配置具体的校验规则 - name配置验证字段的名称 - rules验证规则 - rules=&quot;requried&quot;单个验证规则 - rules=&quot;required|length:4&quot;多个验证规则使用|分隔 - v-slot=&quot;{ errors }&quot;获取错误消息，使用errors[0]绑定展示错误消息 1234567891011121314// 添加自定义验证规则extend('positive', value =&gt; { return value &gt;= 0;});// 使用验证规则import { validate } from 'vee-validate'// 参数1：要验证的数据 参数2：验证规则// 参数3：一个可选的配置对象，例如配置错误消息字段名称 name// 返回值：{ valid, errors, ... }// valid: 验证是否成功，成功 true，失败 false// errors：一个数组，错误提示消息validate(mobile, 'required|mobile', { name: '手机号'}) 5、手动触发验证规则（通过this.$refs.myform.errors获取错误信息） 给ValidationObserver组件添加一个ref属性 调用组件的validate方法 1const success = await this.$refs.form.validate()","link":"/2018/03/01/Vue%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"Proxy和Object.defineProperty","text":"Proxy与Object.defineProperty一、Proxylet proxy = new Proxy(target, handler); tgarget：要代理的目标对象。（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler：定义拦截行为的配置对象（也是一个对象，其内部的属性均为执行操作的函数）。 1、set(target, key, value, receiver) 拦截对象属性的设置 target：要代理的目标对象。 key：要设置的属性名。 value：要设置的属性值。 receiver：proxy实例（可选参数，一般不用）。 123456789101112131415161718192021function Monster() { this.eyeCount = 4;}const handler1 = { set(obj, prop, value) { if ((prop === 'eyeCount') &amp;&amp; ((value % 2) !== 0)) { console.log('Monsters must have an even number of eyes'); } else { return Reflect.set(...arguments); } }};const monster1 = new Monster();const proxy1 = new Proxy(monster1, handler1);proxy1.eyeCount = 1;// expected output: \"Monsters must have an even number of eyes\"console.log(proxy1.eyeCount);// expected output: 4 2、get(target, key, receiver) 拦截对象属性的读取 target：要代理的目标对象。 key：属性名。 receiver：proxy实例（可选参数，一般不用） 123456789var p = new Proxy({}, { get: function(target, prop, receiver) { console.log(\"called: \" + prop); return 10; }});console.log(p.a); // \"called: a\" // 10 3、has(target, Key) 判断对象是否具有某个属性。 target：要代理的目标对象。 key：要设置的属性名。 1234567891011121314151617181920212223const handler1 = { has(target, key) { if (key[0] === '_') { return false; } return key in target; }};const monster1 = { _secret: 'easily scared', eyeCount: 4};const proxy1 = new Proxy(monster1, handler1);console.log('eyeCount' in proxy1);// expected output: trueconsole.log('_secret' in proxy1);// expected output: falseconsole.log('_secret' in monster1);// expected output: true 4、apply(target, thisArgs, args) 拦截函数的调用、call和apply操作 target：目标对象。 thisArgs：目标对象的上下文对象（this）。 args：目标对象的参数数组。 12345678910111213141516171819function sum(a, b) { return a + b;}const handler = { apply: function(target, thisArg, argumentsList) { console.log(`Calculate sum: ${argumentsList}`); // expected output: \"Calculate sum: 1,2\" return target(argumentsList[0], argumentsList[1]) * 10; }};const proxy1 = new Proxy(sum, handler);console.log(sum(1, 2));// expected output: 3console.log(proxy1(1, 2));// expected output: 30 5、construct(target, args，newTarget) 拦截new命令 target：目标对象。 args：构造函数的参数列表。 newTarget：创建实例对象时，new命令作用的构造函数（下面例子的p） 1234567891011121314151617function monster1(disposition) { this.disposition = disposition;}const handler1 = { construct(target, args) { console.log('monster1 constructor called'); // expected output: \"monster1 constructor called\" return new target(...args); }};const proxy1 = new Proxy(monster1, handler1);console.log(new proxy1('fierce').disposition);// expected output: \"fierce\" 6、this问题 二、Object.defineProperty(obj, prop, descriptor)Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性 参数说明： ​ obj：必需。目标对象 ​ prop：必需。需定义或修改的属性的名字 ​ descriptor：必需。目标属性所拥有的特性 返回值： ​ 传入函数的对象。即第一个参数obj 属性： 1234567configurable：表示该属性能否通过delete删除，能否修改属性的特性或者能否修改访问器属性，默认为false。当且仅当该属性的configurable为true时，才能实现上述行为。enumerable：表示该属性是否可以枚举，即可否通过for..in访问属性。默认为false。get：在读取属性时调用的函数，默认值为undefined。set：在写入属性时调用的函数，默认值为undefined。 存取描述符 –是由一对 getter、setter 函数功能来描述的属性 get：一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。 set：一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined。","link":"/2020/07/10/Proxy/"},{"title":"Webpack入门","text":"webpackwebpack介绍 举例:一个项目中可以设置许多less文件，每个less文件需要被编译为普通的css文件内容查才可以执行，一个项目中如果有许多less文件，每个都分别编译，工作效率低下,可以用webpack统一解决!!! 举例es6/es7内容，项目发布后为了使得全部的浏览器都可以执行该项目(兼容性要更好)，就要对es6、es7的高级内容做降级处理，降级为es5的内容，每个es6或es7的内容逐个降级处理，工作效率低下,可以用webpack统一解决!!! webpack：一次性把项目中全部的es6、es7的高级内容降级为es5标准，提高开发效率 webpack是一个现代JavasScript应用程序的模块打包器 webpack本质上是一个帮助开发者完成 开发调试,应用程序打包的百宝箱工具,其包含众多的插件,模块,可以帮助开发者配置 并编译打包应用程序. 图片资源/样式/ES6/ES7 高级语法 都可以通过webpack进行 相应的打包,编译. 还可以采用webpack-dev-server 进行 开启本地服务, 进行实时打包预览 webpack 本身是nodejs的一个工具框架,所以webpack本质是对于服务器或者本地文件进行操作 为什么使用webpack 现在好多网页有着很多的应用，所以它们的JavaScript代码比较复杂，当然也有着很多的依赖包，所以为了简化开发的复杂度，前端就出现了很多比较好的实践方法： 模块化，让我们可以把复杂的程序细化为小的文件; 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别； scss，less等CSS预处理器 …… 等等 这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。 webpack的优点 模块化 这个毋庸置疑，WebPack本来就可以看做是模块打包机，将项目结构模块化 代码拆分 Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包 Loader Webpack 本身只能处理原生的JavaScript模块，但是 loader 转换器可以将各种类型的资源转换成 javascript模块，这样，任何资源都可以成为 Webpack 可以处理的模块。比如说Webpack 本身是处理不了css的，但是它有css-loader，将css转换成js可以处理的模块 智能解析 Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 js文件。甚至在加载依赖的时候，允许使用动态表达式 `require(“./templates/“ + name + “.jade”) 插件系统 插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。 Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能 快速运行 Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译 webpack的工作方式 Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。 步骤： 创建项目目录 demo(注意,包名不能叫webpack) 给项目 创建package.json文件 1$ npm init // 初始化一个npm项目 在webpack目录下 创建src目录,src目录作为我们的源代码目录 安装 jquery 1$ npm i jquery -S # 安装到运行时依赖 在webpack目录下创建index.html文件,并在src目录下创建index.js文件 在index.js中实现如下代码 1var liHtml = [] 1for (var i = 0; i &lt; 100; i++) { 1liHtml.push(`&lt;li &gt;我是第${i + 1}个里标签,你看我的颜色!!!!&lt;/li&gt;`) 1} 1$('#app').append(`&lt;ul&gt;${liHtml.join(&quot;&quot;)}&lt;/ul&gt;`) 1$(&quot;li:even&quot;).css({ background: 'pink', color: '#fff', fontSize: '30px' }) 在index.html 引入 jquery.js 和 index.js 预览index.html 计划： 安装webpack，并把index.js 和 jquery.js 两个文件给打包到一个文件里边去 webpack安装配置 官网 步骤： 安装,webpack 和脚手架 1$ npm i webpack webpack-cli -D 在package.json中做如下配置: package.json内部内容语法是json格式，因此有固定要求 不能写注释 成员名称 与 成员值 都需要通过 双引号 圈选 (不能使用单引号) build可以自定义为其他，但是webpack字眼是固定的 当前步骤完成，那么就可以通过如下指令进行打包处理了 1$ npm run build # 会执行命令 webpack =&gt; webpack 就是打包命令 我们执行上述命令会出现下图 我们并没有配置 入口 和出口之类的东西 ,但是webpack 自己去找了文件,所以webpack在没有任何配置的情况下, src下的index.js文件作为打包的入口,输出目录为dist下的main.js webpack打包实现目标： 要把项目中的jquery.js和index.js两个文件打包在一起 步骤： 在src/index.js中 引入jquery， 1import $ from 'jquery' 执行指令打包 1$ npm run build 打包完毕会生成dist目录，合并文件默认名称为main.js main.js文件内容就是jquery.js和index.js的合成体，但是代码都是优化压缩后的 在应用程序文件 src/index.html中去掉对于引入 jquery.js 和 src/index.js的引用, 直接引入打包好的dist/main.js即可 webpack配置打包模式目标给webpack配置打包模式，不配置打包会提示黄色警告 步骤： 项目根目录创建webpack配置文件，名称为 webpack.config.js,这是默认的文件 如果你的文件不想叫webpack.config 或者 不想放置在根目录 ,也可以,但是执行打包命令时,需要指定需要打包的文件 1$ webpack --config 路径 给webpack.config.js做如下配置 production： 生产模式，打包的文件是优化压缩的 development：开发模式，打包的文件有适当的回车、空白、注释 前期使用development，项目开发完毕即将上线就用production webpack配置入口和出口文件 目标将隔行换色的案例改成 黑马头条的 样子 项目主模板文件：index.html(类似头条项目的 public/index.html) 项目主入口文件：src/index.js (类似头条项目的 src/main.js) 项目出口文件：dist/main.js (类似头条项目的 dist/js/chunk***.js) 现在我们要对入口和出口文件做配置(变为 头条项目的样子) 入口：src/main.js 出口：dist/chunk.js 步骤： src/index.js文件改名字为 src/main.js 给webpack.config.js做如下配置 物理打包 npm run build webpack编译模板页面目标实现html页面中自动引入文件,去除手动方式的引用 目前给项目做打包处理，要通过手动方式在src/index.html中引入打包好的chunk.js文件，太笨了 webpack有一个工具，可以实现同时打包/(复制)src/index.html到达dist目录，并自动就引入chunk.js文件，我们要做到的事情就是直接运行打包好的模板文件即可 实现步骤： 安装工具, yarn add html-webpack-plugin -D 1$ npm i html-webpack-plugin -D 在webpack.config.js中配置如下信息：,需要注意的是,这是一个插件,需要配置在plugins选项下 1234new htmlPlugin({ template: path.resolve('./public/index.html'), filename:'../index.html' // 写入HTML的文件。默认为index.html。您可以在这里指定一个子目录太（如：assets/admin.html） }) 在src/index.html模板中不用引入任何的js文件了 做物理打包 npm run build（编译生成模板文件了，并且有自动引入chunk.js文件） webpack实时打包 目标实现 npm run serve 启动项目 实时打包 注意： 项目开发都是对src目录内部的文件进行更新，不要去修改dist打包好的文件 现在对src内部的任何文件做修改操作后，都需要重新打包，才可以看到对应效果 webpack本身有一个工具，名称为 webpack-dev-server，可以实现随时修改源文件，浏览器随时看到修改后的效果，不需要反复打包，这样就非常好 webpack-dev-server安装运行起来之后，会给我们创建一个http的web服务 步骤： 安装 1$ npm i webpack-dev-server -D 在webpack.config.js中做如下配置 在package.json中做如下配置 现在通过 npm run serve 就可以实现 实时打包、实时编译、实时浏览器查看效果了 注意： npm run serve指令执行后，其是一个“前台”进程，不能关闭 浏览器看到的实时效果是服务器通过“内存”提供的，没有物理文件，也不会生成dist目录 webpack-loader-运行css文件目标：在当前项目中创建css文件并做引入使用 步骤： 创建css文件 src/styles/index.css， 和简单的样式 123li { color: red;} 在main.js中引入css文件 ， 1import './styles/index.css' 此时实时打包报错了 错误提示：需要一个适当的loader来处理css文件 webpack-loader-介绍webpack很厉害，可以打包处理不同的内容(css/img/less/es6、es7等等)，但是具体处理工作webpack不参与，具体交给手下 loader去处理，loader是小兵，帮助webpack对不同内容做编码、降级处理 准确定义： webpack本身就是一个打包机器，其不能对具体代码内容部分进行处理(或处理得非常有限)，不同的代码内容(less/scss/ES6(ES7)/image/css等等)需要webpack找到不同的loader(装载器)实现转码、编译、降级处理。 webpack-loader-安装配置css相关loader目标 安装配置css相关的loader css内容相关的loader有：style-loader 和 css-loader 安装配置步骤： 安装, 1$ npm i css-loader style-loader -D 在webpack.config.js中做如下配置 现在重新 实时打包 npm run serve,发现 css文件的样式已经生效 问：生成好的css内容在哪？ 答：css的loader会把1.css文件的样式内容合并到chunk.js打包文件里边, 之后应用执行时，chunk.js会把css内容通过style标签的形式嵌入的应用文档内部，样式就生效了 1use: ['style-loader', 'css-loader'], 上述两个loader配置有严格的”一前一后”顺序，本质执行时，是css-loader在前、style-loader在后，这是固定特点 12style-loader：负责让chunk.js内部的css样式信息通过 style 标签方式 嵌入到应用文档中的css-loader: 使得index.css文件可以通过import方式引入进来，并合并到chunk.js文件中去 注意： ​ webpack给打包处理独立文件的css，在index.html模板中设置的行内样式不给处理 webpack-loader-图片处理和file-loader目标： 给整个页面设置背景图片 步骤： 在assets目录下 放置一张背景图片 给#app设置背景图片 在index.css样式文件中给div设置背景图片 1#app { 1background-image: url('../assets/image/back.jpg'); 1background-size: cover; 1} 现在实时打包报错了 错误说明：图片的引入不ok，需要loader来处理 webpack-loader-安装配置图片相关loader目标 安装配置图片相关的loader img图片相关的loader有两个：url-loader 和 file-loader 安装配置loader步骤： 安装 1$ npm i url-loader file-loader -D webpack.config.js中做具体配置，如下 现在重新实时打包 npm run serve，发现页面上已经有背景图片效果了 12345678910111213141516{ // 2) 图片处理loader配置 test: /\\.(png|jpg|gif|jpeg)$/i, // 正则匹配图片文件 // 遇到图片文件就交给如下loader处理 use: [ { loader: 'url-loader', options: { // limit:设定大小阀值 // a. 被处理图片大小 大于该阀值，就通过物理文件重新生成该图片 // b. 被处理图片大小 小于等于该阀值，就把图片变为字符串(嵌入到应用文档中，好处是节省一个http资源) limit: 8192 } } ]}, loader说明： 只配置url-loader，file-loader不用配置，条件满足后url-loader会自动调用file-loader执行 limit:8192设置图片判断大小阀值的，一般建议是10k左右，原因是图片变为字符串大小会增加的(过大图片变为字符串我们就没有”利润”了) 12url-loader: 负责把 小于等于 阀值的图片变为字符串file-loader: 负责把 大于阀值 的图片重新以物理文件形成生成在dist目录 我们也可以只用file-loader来处理这类文件,那么所有的文件都会被拷贝到dist目录下,之前处理的字体图标就是把所有的字体图标都拷贝了过去 注意： ​ 图片loader只能处理css文件的背景图片，而index.html模板中通过img标签做的图片不给处理(只把其当做标签的普通属性了) webpack-loader-打包好图片在哪现在给项目做物理打包： 小于阈值小图片就变为base64字符串存储，该字符串合并到 chunk.js文件中，应用执行的时候会被通过style标签形式以样式形式呈现 大于阈值大图片就直接生成的dist目录，其是通过具体路径名方式被访问 可以给loader做配置，使得物理图片在dist下的某一个子目录生成出来 ​ outputPath虽然是file-loader的配置信息，但是可以给url-loader使用，它们内部会有沟通，url-loader会把该参数给到file-loader去使用的 loader-base64字符串图片说明webpack把img图片变为字符串后，名称为base64格式字符串 什么是base64格式？ 答：Base64就是一种基于64个可打印字符来表示二进制数据的方法。 一个图片可以变为二进制数据，该数据再编码为base64格式 webpack-loader-应用less文件及安装配置less相关loader目标安装配置less相关loader 创建 src/styles/second.less文件，并设置简单样式 12345ul{ li{ border:2px solid orange; }} 在main.js中引入less文件 1import './styles/second.less' 此时实时打包报错，告诉less缺少对应loader来处理 loader具体为：less-loader、less 步骤： 安装依赖包 1$ npm i less-loader less -D webpack.config.js做如下配置 现在在重新实时打包运行 npm run serve，发现less设置样式已经生效 webpack-loader-less相关loader解读12345{ // 3) less处理loader配置 test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;]}, 说明： ​ less样式文件处理需要3个loader，具体为上述，它们有严格的顺序，它们有做工作交接 ​ 它们执行的顺序是颠倒的(less&gt;css&gt;style) 12345style-loader：负责生成style标签，把css样式体现出来，之后该标签嵌入到应用文档中去css-loader：使得css文件可以通过import引入，并合并到chunk.js中less-loader: 该loader负责把less文件内容转变为 css内容 less样式内容经过loader处理完毕，在哪？ 答：在chunk.js中 webpack-loader-运行es6标准代码,及babel-loader配置应用es6高级标准技术 步骤： 在main.js中应用es6内容(let、箭头函数、对象解构赋值、…展开运算符、反勾号字符串等等) 1import $ from 'jquery' 1import './styles/index.css' 1import './styles/second.less' 1let liHtml = [] 1for (var i = 0; i &lt; 100; i++) { 1liHtml.push(`&lt;li &gt;我是第${i + 1}个里标签,你看我的颜色!!!!&lt;/li&gt;`) 1} 1let bossName = '陈浩南' 1let strTemplate = ` 1&lt;li&gt;我是老大${bossName},都听我的!!!&lt;/li&gt; 1` 1let newList = [strTemplate,...liHtml] // ES6解构赋值 1$('#app').append(`&lt;ul&gt;${newList.join(\"\")}&lt;/ul&gt;`) 1$(\"li:even\").css({ background: 'pink', color: '#fff', fontSize: '30px' }) 给项目做物理打包 npm run build 发现情况不好，在chunk.js中生成的内容还是es6高级的信息 我们本意是要把es6变为es5的，但是失败了 loader-babel-loader和preset和plugin关键字解读能够把es6高级内容变为es5的loader名称为 babel-loader 实际处理是这样的 es6/es7/es8等等高级标准有很多(let、箭头函数、对象解构赋值、…展开运算符、反勾号字符串等等)，每个标准都需要一个独立的plugin进行降级处理，如果使用许多高级标准内容，那么势必要为此安装许多plugin，这样工作比较繁琐，系统已经考虑到这点了，其通过preset把许多常用的plugin给做了集合，因此一般性的使用只需要安装preset即可搞定(如果项目应用到了一个生僻的高级标准内容，preset处理不来，就还需要再安装对应的plugin处理) let—-降级—-&gt;plugin 箭头函数—-降级—&gt;plugin loader-安装配置loader和preset做降低处理babel-loader官网：https://babel.docschina.org/ 步骤： 安装依赖包 1$ npm i babel-loader @babel/core @babel/preset-env -D 在webpack.config.js中做如下配置： 在项目根目录创建 babel.config.js文件，配置如下 作用：使得babel-loader可以找到preset做代码降级处理 现在给项目做物理打包 npm run build,发现高级内容已经降级处理了 webpack-安装配置vue-loader处理单文件组件 目标 配置针对.vue相关的loader,完成一个基本的小项目 安装vuejs 1$ npm i vue -S 在src下新建一个App.vue文件 ,写入如下内容 1&lt;div class='app'&gt; 1&lt;span&gt;Hello world&lt;/span&gt; 1&lt;/div&gt; 1&lt;/template&gt; 1&lt;script&gt; 1export default {} 1&lt;/script&gt; 1&lt;style&gt;&lt;/style&gt; 在main.js引入,main.js代码改为如下代码 1import Vue from 'vue' 1import App from './App.vue' 1new Vue({ 1render: h =&gt; h(App) 1}).$mount(\"#app\") 执行npm run serve,发现报错!!!! 我们需要安装loader依赖 1$ npm i vue-loader vue-template-compiler vue-style-loader -D . Vue-loader在15.*之后的版本都是 vue-loader的使用都是需要伴生 VueLoaderPlugin的, 所以我们还需要一个操作,安装完毕依赖之后,在配置文件 中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = { mode: 'development', // development 开发模式 prodution 生产模式 entry: path.resolve('./src/main.js'), // 入口 output: { // 出口 path: path.resolve('./dist'), // 输出文件目录 filename: 'chunk.js', // 输出文件名称 }, plugins: [ new HtmlWebpackPlugin({ template: path.resolve('./index.html') // 打包时自动引入html模板 }), new MiniCssExtractPlugin({ filename: '[name].css', // 打包时生成link标签引入css文件名称及目录 }) ], devServer: { // 开启热更新模式 port: 3003, // 开启端口号 open: true, // 自动打开浏览器 }, module: { rules: [ // 针对不同的资源进行处理 // { // 处理css样式 // test: /\\.css$/, // 正则表达式，校验文件类型 // use: ['style-loader', 'css-loader'] // 三种方式：字符串、 // // 数组=&gt;数组字符串、数组对象 // }, { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, // 把样式抽离成link标签引入 'css-loader', ] }, { // 处理less样式 test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, { // 处理js文件es6语法 test: /\\.js$/, exclude: /node_moudles/, // 排除node_modules文件夹下的js文件 use: 'babel-loader', }, { // 处理图片 test:/\\.(png|gif|jpg|jpeg|bmp)$/i, use: [ { loader: 'url-loader', options: { limit: 8192, // 图片的阈值，小于这个阈值转成base64 // 字符转,大于的话使用file-loader生成 // 物理文件,不需要配置file-loader outputPath: 'img', // 输出到指定目录下 esModule: false, // 该配置项为图片打包后的默认路径,带default // 对象,默认为ture，在配置项里将此项改 // 为false即可去掉多余的defalut对象 } }, ] }, { // 处理html文件中的img标签 test: /\\.html$/, use: 'html-withimg-loader', }, ] }} 配置babel.config.js 123module.exports = { presets: ['@babel/preset-env']}","link":"/2019/07/20/Webpack%E5%85%A5%E9%97%A8/"},{"title":"npm全局安装包后无法使用问题解决","text":"问题：使用npm安装typescript明明安装成功，但在使用时一直报错，报错语句为 tsc不是内部或外部命令，也不是可运行的程序或批处理文件 具体原因：node未正确安装，或相关环境变量未正确配置 解决方案：配置环境变量“我的电脑”右键“属性”-“高级系统设置”-“高级”-“环境变量”。 新建系统变量 NODE_PATH 进入环境变量对话框，在系统变量下新建”NODE_PATH”，输入”D:\\Program Files\\Nodejs\\node_global“。 （说明：在安装nodejs时配置了全局文件夹和缓存文件夹，所以node_path 值是”D:\\Program Files\\Nodejs\\node_global“。如果在装node时候，没有配置全局文件和缓存两个文件夹，此处NODE_PATH的值为“用下面的没命令查看”） npm目录可以使用npm命令去查找：npm config get prefix 用户变量和系统变量Path，添加值：%NODE_PATH% 在配置完变量后，关闭dos命令窗口重启dos命令，输入命令，查看是否成功。","link":"/2020/04/04/npm%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"title":"前端通过Blob实现文件下载","text":"最近遇到一个需求，需要将页面中的配置信息下载下来供用户方便使用，以前这个场景的需求有时候会放到后端处理，然后给返回一个下载链接。其实并不需要这么麻烦，这样既增大了服务器的负载，也让用户产生了没有必要的网络请求，现在前端也是可以直接通过Blob对象进行前端文件下载了，下面简单记录下相关实现 Blob对象简要介绍 Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件 语法1const aBlob = new Blob( array, options ); 参数说明 array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。 options 是一个可选的BlobPropertyBag字典，它可能会指定如下两个属性： type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。 endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。 它是以下两个值中的一个： “native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持blob中保存的结束符不变 示例12const debug = {hello: \"world\"};const blob = new Blob([JSON.stringify(debug, null, 2)],{type : 'application/json'}); URL.createObjectURL() 与 URL.revokeObjectURL()介绍URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。相当于这个方法创建了一个传入对象的内存引用地址 createObjectURL语法1objectURL = URL.createObjectURL(object); 参数说明 object 是用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。 返回值 一个可以引用到指定对象的DOMString URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道不用在内存中继续保留对这个文件的引用了。 你可以在 sourceopen 被处理之后的任何时候调用 revokeObjectURL()。这是因为 createObjectURL() 仅仅意味着将一个媒体元素的 src 属性关联到一个 MediaSource 对象上去。调用revokeObjectURL() 使这个潜在的对象回到原来的地方，允许平台在合适的时机进行垃圾收集。 revokeObjectURL语法1window.URL.revokeObjectURL(objectURL); 参数说明 objectURL 是一个 DOMString，表示通过调用 URL.createObjectURL() 方法产生的 URL 对象 内存管理 在每次调用createObjectURL() 方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。 实际运用 比如在某后台管理中希望将用户的几个配置信息导入到一个json文件当中供用户下载下来 123456789101112131415161718192021222324252627const config = { name: 'lsqy', password: 'yourpassword', ak: 'XXXXXXXXXX', sk: 'XXXXXXXXXX'}const blobContent = new Blob( [JSON.stringify(config, null, 2)], {type : 'application/json'});const blobUrl = window.URL.createObjectURL(blobContent)downloadFileByBlob(blobUrl, 'config.json')function downloadFileByBlob(blobUrl, filename) { const eleLink = document.createElement('a') eleLink.download = filename eleLink.style.display = 'none' eleLink.href = blobUrl // 触发点击 document.body.appendChild(eleLink) eleLink.click() // 然后移除 document.body.removeChild(eleLink)} 执行上面的代码，我们可以得到一个config.json的文件，可以看到，其实很简单就实现了这个场景需求，当然这里是下载的json文件,下载其他的文件也是一样的道理，只是需要得到相应文件的blob数据，再结合相应的MIME类型即可; 兼容性方面目前主流浏览器都已支持，ie10以及以上也支持。 另外Blob结合URL. createObjectURL()与URL.revokeObjectURL()还可以用在预览图片、预览PDF、视频链接防盗等多种场景中，大家可以发挥自己的想象力来进行实现 Mime类型按照内容类型排列的 Mime 类型列表 类型/子类型 扩展名 application/envoy evy application/fractals fif application/futuresplash spl application/hta hta application/internet-property-stream acx application/mac-binhex40 hqx application/msword doc application/msword dot application/octet-stream * application/octet-stream bin application/octet-stream class application/octet-stream dms application/octet-stream exe application/octet-stream lha application/octet-stream lzh application/oda oda application/olescript axs application/pdf pdf application/pics-rules prf application/pkcs10 p10 application/pkix-crl crl application/postscript ai application/postscript eps application/postscript ps application/rtf rtf application/set-payment-initiation setpay application/set-registration-initiation setreg application/vnd.ms-excel xla application/vnd.ms-excel xlc application/vnd.ms-excel xlm application/vnd.ms-excel xls application/vnd.ms-excel xlt application/vnd.ms-excel xlw application/vnd.ms-outlook msg application/vnd.ms-pkicertstore sst application/vnd.ms-pkiseccat cat application/vnd.ms-pkistl stl application/vnd.ms-powerpoint pot application/vnd.ms-powerpoint pps application/vnd.ms-powerpoint ppt application/vnd.ms-project mpp application/vnd.ms-works wcm application/vnd.ms-works wdb application/vnd.ms-works wks application/vnd.ms-works wps application/winhlp hlp application/x-bcpio bcpio application/x-cdf cdf application/x-compress z application/x-compressed tgz application/x-cpio cpio application/x-csh csh application/x-director dcr application/x-director dir application/x-director dxr application/x-dvi dvi application/x-gtar gtar application/x-gzip gz application/x-hdf hdf application/x-internet-signup ins application/x-internet-signup isp application/x-iphone iii application/x-javascript js application/x-latex latex application/x-msaccess mdb application/x-mscardfile crd application/x-msclip clp application/x-msdownload dll application/x-msmediaview m13 application/x-msmediaview m14 application/x-msmediaview mvb application/x-msmetafile wmf application/x-msmoney mny application/x-mspublisher pub application/x-msschedule scd application/x-msterminal trm application/x-mswrite wri application/x-netcdf cdf application/x-netcdf nc application/x-perfmon pma application/x-perfmon pmc application/x-perfmon pml application/x-perfmon pmr application/x-perfmon pmw application/x-pkcs12 p12 application/x-pkcs12 pfx application/x-pkcs7-certificates p7b application/x-pkcs7-certificates spc application/x-pkcs7-certreqresp p7r application/x-pkcs7-mime p7c application/x-pkcs7-mime p7m application/x-pkcs7-signature p7s application/x-sh sh application/x-shar shar application/x-shockwave-flash swf application/x-stuffit sit application/x-sv4cpio sv4cpio application/x-sv4crc sv4crc application/x-tar tar application/x-tcl tcl application/x-tex tex application/x-texinfo texi application/x-texinfo texinfo application/x-troff roff application/x-troff t application/x-troff tr application/x-troff-man man application/x-troff-me me application/x-troff-ms ms application/x-ustar ustar application/x-wais-source src application/x-x509-ca-cert cer application/x-x509-ca-cert crt application/x-x509-ca-cert der application/ynd.ms-pkipko pko application/zip zip audio/basic au audio/basic snd audio/mid mid audio/mid rmi audio/mpeg mp3 audio/x-aiff aif audio/x-aiff aifc audio/x-aiff aiff audio/x-mpegurl m3u audio/x-pn-realaudio ra audio/x-pn-realaudio ram audio/x-wav wav image/bmp bmp image/cis-cod cod image/gif gif image/ief ief image/jpeg jpe image/jpeg jpeg image/jpeg jpg image/pipeg jfif image/svg+xml svg image/tiff tif image/tiff tiff image/x-cmu-raster ras image/x-cmx cmx image/x-icon ico image/x-portable-anymap pnm image/x-portable-bitmap pbm image/x-portable-graymap pgm image/x-portable-pixmap ppm image/x-rgb rgb image/x-xbitmap xbm image/x-xpixmap xpm image/x-xwindowdump xwd message/rfc822 mht message/rfc822 mhtml message/rfc822 nws text/css css text/h323 323 text/html htm text/html html text/html stm text/iuls uls text/plain bas text/plain c text/plain h text/plain txt text/richtext rtx text/scriptlet sct text/tab-separated-values tsv text/webviewhtml htt text/x-component htc text/x-setext etx text/x-vcard vcf video/mpeg mp2 video/mpeg mpa video/mpeg mpe video/mpeg mpeg video/mpeg mpg video/mpeg mpv2 video/quicktime mov video/quicktime qt video/x-la-asf lsf video/x-la-asf lsx video/x-ms-asf asf video/x-ms-asf asr video/x-ms-asf asx video/x-msvideo avi video/x-sgi-movie movie x-world/x-vrml flr x-world/x-vrml vrml x-world/x-vrml wrl x-world/x-vrml wrz x-world/x-vrml xaf x-world/x-vrml xof 按照文件扩展名排列的 Mime 类型列表 扩展名 类型/子类型 application/octet-stream 323 text/h323 acx application/internet-property-stream ai application/postscript aif audio/x-aiff aifc audio/x-aiff aiff audio/x-aiff asf video/x-ms-asf asr video/x-ms-asf asx video/x-ms-asf au audio/basic avi video/x-msvideo axs application/olescript bas text/plain bcpio application/x-bcpio bin application/octet-stream bmp image/bmp c text/plain cat application/vnd.ms-pkiseccat cdf application/x-cdf cer application/x-x509-ca-cert class application/octet-stream clp application/x-msclip cmx image/x-cmx cod image/cis-cod cpio application/x-cpio crd application/x-mscardfile crl application/pkix-crl crt application/x-x509-ca-cert csh application/x-csh css text/css dcr application/x-director der application/x-x509-ca-cert dir application/x-director dll application/x-msdownload dms application/octet-stream doc application/msword dot application/msword dvi application/x-dvi dxr application/x-director eps application/postscript etx text/x-setext evy application/envoy exe application/octet-stream fif application/fractals flr x-world/x-vrml gif image/gif gtar application/x-gtar gz application/x-gzip h text/plain hdf application/x-hdf hlp application/winhlp hqx application/mac-binhex40 hta application/hta htc text/x-component htm text/html html text/html htt text/webviewhtml ico image/x-icon ief image/ief iii application/x-iphone ins application/x-internet-signup isp application/x-internet-signup jfif image/pipeg jpe image/jpeg jpeg image/jpeg jpg image/jpeg js application/x-javascript latex application/x-latex lha application/octet-stream lsf video/x-la-asf lsx video/x-la-asf lzh application/octet-stream m13 application/x-msmediaview m14 application/x-msmediaview m3u audio/x-mpegurl man application/x-troff-man mdb application/x-msaccess me application/x-troff-me mht message/rfc822 mhtml message/rfc822 mid audio/mid mny application/x-msmoney mov video/quicktime movie video/x-sgi-movie mp2 video/mpeg mp3 audio/mpeg mpa video/mpeg mpe video/mpeg mpeg video/mpeg mpg video/mpeg mpp application/vnd.ms-project mpv2 video/mpeg ms application/x-troff-ms mvb application/x-msmediaview nws message/rfc822 oda application/oda p10 application/pkcs10 p12 application/x-pkcs12 p7b application/x-pkcs7-certificates p7c application/x-pkcs7-mime p7m application/x-pkcs7-mime p7r application/x-pkcs7-certreqresp p7s application/x-pkcs7-signature pbm image/x-portable-bitmap pdf application/pdf pfx application/x-pkcs12 pgm image/x-portable-graymap pko application/ynd.ms-pkipko pma application/x-perfmon pmc application/x-perfmon pml application/x-perfmon pmr application/x-perfmon pmw application/x-perfmon pnm image/x-portable-anymap pot, application/vnd.ms-powerpoint ppm image/x-portable-pixmap pps application/vnd.ms-powerpoint ppt application/vnd.ms-powerpoint prf application/pics-rules ps application/postscript pub application/x-mspublisher qt video/quicktime ra audio/x-pn-realaudio ram audio/x-pn-realaudio ras image/x-cmu-raster rgb image/x-rgb rmi audio/mid roff application/x-troff rtf application/rtf rtx text/richtext scd application/x-msschedule sct text/scriptlet setpay application/set-payment-initiation setreg application/set-registration-initiation sh application/x-sh shar application/x-shar sit application/x-stuffit snd audio/basic spc application/x-pkcs7-certificates spl application/futuresplash src application/x-wais-source sst application/vnd.ms-pkicertstore stl application/vnd.ms-pkistl stm text/html svg image/svg+xml sv4cpio application/x-sv4cpio sv4crc application/x-sv4crc swf application/x-shockwave-flash t application/x-troff tar application/x-tar tcl application/x-tcl tex application/x-tex texi application/x-texinfo texinfo application/x-texinfo tgz application/x-compressed tif image/tiff tiff image/tiff tr application/x-troff trm application/x-msterminal tsv text/tab-separated-values txt text/plain uls text/iuls ustar application/x-ustar vcf text/x-vcard vrml x-world/x-vrml wav audio/x-wav wcm application/vnd.ms-works wdb application/vnd.ms-works wks application/vnd.ms-works wmf application/x-msmetafile wps application/vnd.ms-works wri application/x-mswrite wrl x-world/x-vrml wrz x-world/x-vrml xaf x-world/x-vrml xbm image/x-xbitmap xla application/vnd.ms-excel xlc application/vnd.ms-excel xlm application/vnd.ms-excel xls application/vnd.ms-excel xlt application/vnd.ms-excel xlw application/vnd.ms-excel xof x-world/x-vrml xpm image/x-xpixmap xwd image/x-xwindowdump z application/x-compress zip application/zip","link":"/2010/08/06/%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87Blob%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"title":"通过Blob实现图片下载","text":"问题：通过iframe的方式下载图片的时候，不能够修改图片的名字解决思路： 因为图片地址是跨域的，所以先要转成 base64 数据流 然后把 base64 转换成 blob对象 然后判断浏览器的类型，选择不同的方式把 blob 文件流下载到本地 转换成base64的方法123456789101112131415161718192021222324convertUrlToBase64(url) { return new Promise(function(resolve, reject) { var img = new Image(); img.crossOrigin = \"Anonymous\"; img.src = url; img.onload = function() { var canvas = document.createElement(\"canvas\"); canvas.width = img.width; canvas.height = img.height; var ctx = canvas.getContext(\"2d\"); ctx.drawImage(img, 0, 0, img.width, img.height); var ext = img.src .substring(img.src.lastIndexOf(\".\") + 1) .toLowerCase(); var dataURL = canvas.toDataURL(\"image/\" + ext); var base64 = { dataURL: dataURL, type: \"image/\" + ext, ext: ext }; resolve(base64); }; });} 转换成 blob 对象123456789101112convertBase64UrlToBlob(base64) { var parts = base64.dataURL.split(\";base64,\"); var contentType = parts[0].split(\":\")[1]; var raw = window.atob(parts[1]); var rawLength = raw.length; var uInt8Array = new Uint8Array(rawLength); for (var i = 0; i &lt; rawLength; i++) { uInt8Array[i] = raw.charCodeAt(i); } return new Blob([uInt8Array], { type: contentType });} 判断浏览器的类型12345678910111213141516171819202122myBrowser() { var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 if (userAgent.indexOf(\"OPR\") &gt; -1) { return \"Opera\"; } //判断是否Opera浏览器 OPR/43.0.2442.991 if (userAgent.indexOf(\"Firefox\") &gt; -1) { return \"FF\"; } //判断是否Firefox浏览器 Firefox/51.0 if (userAgent.indexOf(\"Trident\") &gt; -1) { return \"IE\"; } //判断是否IE浏览器 Trident/7.0; rv:11.0 if (userAgent.indexOf(\"Edge\") &gt; -1) { return \"Edge\"; } //判断是否Edge浏览器 Edge/14.14393 if (userAgent.indexOf(\"Chrome\") &gt; -1) { return \"Chrome\"; } // Chrome/56.0.2924.87 if (userAgent.indexOf(\"Safari\") &gt; -1) { return \"Safari\"; } //判断是否Safari浏览器 AppleWebKit/534.57.2 Version/5.1.7 Safari/534.57.2} 把获取的地址传入上面的方法，然后判断浏览器的类型12345678910111213141516171819//图片格式和PDFfunction downloadImage() { convertUrlToBase64(url).then(function(base64) { // 图片转为base64 var blob = that.convertBase64UrlToBlob(base64); // 转为blob对象 // 下载 if (myBrowser() == \"IE\") { window.navigator.msSaveBlob(blob, name + \".jpg\"); } else if (myBrowser() == \"FF\") { window.location.href = url; } else { var a = document.createElement(\"a\"); a.download = name; a.href = URL.createObjectURL(blob); a.click(); } })}","link":"/2020/08/06/%E9%80%9A%E8%BF%87Blob%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/"},{"title":"Vue组件通信","text":"","link":"/2016/04/13/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"},{"title":"node","text":"fs模块文件系统（fs 模块）模块中的方法均有异步和同步版本 异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。 建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 读文件 123456789101112131415161718// 引入包const fs = require(\"fs\");// file - 文件名或文件描述符。// options - 默认编码为 utf8// callback - 回调函数，回调函数包含错误信息参数和读取数据(err, data)。// 异步读取fs.readFile('file.txt', [options], function (err, data) { if (err) { return console.error(err); } console.log(\"异步读取: \" + data.toString());});// 同步读取var data = fs.readFileSync('input.txt');console.log(\"同步读取: \" + data.toString()); 写文件 123456789101112131415161718const fs = require(\"fs\");// 异步写入// file - 文件名或文件描述符。// data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。// options - 包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ，flag 为 'w'// callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回fs.writeFile('file.txt', [options], function(err) { if (err) { return console.error(err); } console.log(\"数据写入成功！\");});// 同步读取var result = fs.writeFileSync('input.txt');console.log(\"同步写入: \" + result); HTTP模块http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块 使用http模块启动web服务 1234567891011// 引入包var http = require('http');// 创建服务器var server = http.createServer( function (request, response) { // 发送响应数据 response.end(); });// 监听8080端口，控制台会输出以下信息server.listen(8080, () =&gt; { console.log('Server running at http://127.0.0.1:8080/');}) 处理静态资源 123456789101112131415161718192021222324252627var http = require('http');var fs = require('fs');var path = require('path');var server = http.createServer( function (request, response) { // 利用path包可以拼接请求资源绝对路径、解析请求资源后缀 const extname = path.extname(pathname) const filePath = path.join(__dirname, 'public', pathname) fs.readFile(filePath, 'utf8', (err, data) =&gt; { if (err) { response.statusCode = 404 response.end('Not Found') } // 根据不同得文件类型设置响应头 if (extname === '.html') { response.setHeader('Content-type', 'text/html;charset=utf8;') } else if (extname === '.js') { response.setHeader('Content-type', 'text/javascript;charset=utf8;') } else if (extname === '.css') { response.setHeader('Content-type', 'text/css;charset=utf8;') } // 发送响应数据 response.end(); }) });server.listen(8080, () =&gt; { console.log('Server running at http://127.0.0.1:8080/');}) 处理get接口 1234567891011121314var http = require('http');var url = require('url');var server = http.createServer( function (request, response) { if(request.method === 'GET') { // 利用url包可解析出请求的请求路径和query参数，为true后可直接把查询参数解析为对象 const { pathname, query } = url.parse(request.url, true) consoele.log(pathname, query) // 发送响应数据 response.end(); } });server.listen(8080, () =&gt; { console.log('Server running at http://127.0.0.1:8080/');}) 处理post接口 1234567891011121314151617181920var http = require('http');var qs = require('querystring');var server = http.createServer( function (request, response) { if(request.method === 'POST') { let rsData = '' request.on('data',rs =&gt; { rsData += rs }) request.on('end', () =&gt; { // 利用querystring包的parse方法可以解析出请求体传来的参数 let { name, content } = qs.parse(rsData) console.log(name, content) // 发送响应数据 response.end(); }) } });server.listen(8080, () =&gt; { console.log('Server running at http://127.0.0.1:8080/');}) express框架Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。使用您所选择的各种 HTTP 实用工具和中间件，快速方便地创建强大的 API。 Express 框架核心特性： 可以设置中间件来响应 HTTP 请求。 定义了路由表用于执行不同的 HTTP 请求动作。 可以通过向模板传递参数来动态渲染 HTML 页面。 初始化目录 1npm init --yes 安装 1npm install express 使用express创建web服务 12345678// 引如包const express = require('express')// 创建web服务const app = express()// 路由一个apiapp.get('/', (req, res) =&gt; res.send('Hello World!'))// 监听端口app.listen(port, [callback]) 处理静态资源 12// 第一个可选path 第二个静态资源路径app.use([path], express.static('path')) get接口处理 12345678910111213141516171819// 无url参数app.get('/get-no-params', (req, res) =&gt; { console.log(req.query) res.send({ code: 200, message: '请求成功' })})// 有url参数app.get('/get-params', (req, res) =&gt; { console.log(req.query) res.send({ code: 200, message: '请求成功', data: { ...req.query, } })}) post接口处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require('express')const bodyParser = require('body-parser')// Multer 会添加一个body对象以及file或files对象到express的request 对象中。 // body对象包含表单的文本域信息，file或files对象包含对象表单上传的文件信息。const multer = require('multer')const app = express()app.use(express.static('public'))// 处理post类型传参：键值对、表单、json三种数据app.use(bodyParser.urlencoded({ extended: false }))const upload = multer({ dest: 'upload/'})app.use(bodyParser.json())// 处理普通键值对接口app.post('/post-params', (req, res) =&gt; { console.log(req.body) res.send({ code: 200, message: '请求成功', data: { ...req.body, } })})// 处理表单数据文件接口// cover为表单name值app.post('/post-file', upload.single('cover'), (req, res) =&gt; { console.log(req.file) console.log(req.body) res.send({ code: 200, message: '上传成功', data: { ...req.body, url: req.file.path } })})// 处理json数据接口app.post('/post-json', (req, res) =&gt; { console.log(req.body) res.send({ code: 200, message: '请求成功', data: { ...req.body } })}) Ps $.ajax发送post请求小结contentType: 键值对、表单文件、json三种数据 contentType: ‘application/x-www-form-urlencoded’ contentType: ‘multipart/formdata’ contentType: ‘application/json’","link":"/2019/09/14/node/"},{"title":"Cookie","text":"Cookie什么是 Cookie？ Cookie 是一些数据, 存储于你电脑上的文本文件中。 当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。 Cookie 的作用就是用于解决 “如何记录客户端的用户信息”: 当用户访问 web 页面时，他的名字可以记录在 cookie 中。 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。 设置Cookie原生方法 设置单个cookie 1res.setHeader('set-cookie','属性名=属性值'); 设置多个cookie 1res.setHeader('set-cookie',['属性名=属性值','属性名=属性值']); Express方法12345res.cookie('属性名','属性值',{属性});// 这里属性可以设置cookie有限期{ expires: new Date(new Date() + 1000*5)} 服务器获取Cookie12res.headers.cookie// 注意这里查询到的为'a=1;b=2'字符串 原生方法解析 通过replace方法替换；为&amp;后利用queryString包解析为对象 通过cookie-parser包解析 123const cookieParser = require('cookie-parser');app.use(cookieParser())// cookie会保存在req对象中，req.cookies会解析为cookie对象 删除Cookie1res.clearcookie('属性名'); SessionExpress框架处理session123456// 安装npm install express-session// 引入包const session = require('express-session')// 使用包app.use(session(conf)) 设置Session1req.session.属性名 = 属性值 获取Session1req.session.属性名 删除Session1req.session.destroy()","link":"/2018/10/11/Cookie%E5%92%8CSession/"},{"title":"前端前端导出csv文件（通过json2csv前端导出）","text":"第一步：安装依赖1npm install json2csv -s 第二步：代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859rows: [ { title: '序号', key: 'Ordinal', align: 'center' }, { title: '产品编号', key: 'ProductNo', align: 'left' }],fields: ['title','key','align']download(){ try { const result = json2csv.parse(rows, { fields: fields, excelStrings: true }); if (this.MyBrowserIsIE()) { // IE10以及Edge浏览器 var BOM = \"\\uFEFF\"; // 文件转Blob格式 var csvData = new Blob([BOM + result], { type: \"text/csv\" }); navigator.msSaveBlob(csvData, `a.csv`); } else { let csvContent = \"data:text/csv;charset=utf-8,\\uFEFF\" + result; // 非ie 浏览器 this.createDownLoadClick(csvContent, `a.csv`); } } catch (err) { alert(err); }},//创建a标签下载createDownLoadClick(content, fileName) { const link = document.createElement(\"a\"); link.href = encodeURI(content); link.download = fileName; document.body.appendChild(link); link.click(); document.body.removeChild(link);},// 判断是否IE浏览器MyBrowserIsIE() { let isIE = false; if ( navigator.userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; navigator.userAgent.indexOf(\"MSIE\") &gt; -1 ) { // ie浏览器 isIE = true; } if (navigator.userAgent.indexOf(\"Trident\") &gt; -1) { // edge 浏览器 isIE = true; } return isIE;} 导出文件格式： 实际代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051export function exportCsv(self, exportDataList) { getExportColumns(self.activeKey, self); const fields = []; self.exportColumns.forEach(t =&gt; { const temp = { value: t.dataIndex, label: t.title }; fields.push(temp); }); const result = json2csv.parse(exportDataList, { fields: fields, excelStrings: true }); const fileName = self.exportFileName; const BOM = \"\\uFEFF\"; const csvData = new Blob([BOM + result], { type: \"text/csv\" }); if (MyBrowserIsIE()) { // IE10以及Edge浏览器 navigator.msSaveBlob(csvData, `${fileName}.csv`); } else { // 非ie 浏览器 createDownLoadClick(csvData, `${fileName}.csv`); }}export function MyBrowserIsIE() { let isIE = false; if ( navigator.userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; navigator.userAgent.indexOf(\"MSIE\") &gt; -1 ) { // ie浏览器 isIE = true; } if (navigator.userAgent.indexOf(\"Trident\") &gt; -1) { // edge 浏览器 isIE = true; } return isIE;}// 创建a标签下载export function createDownLoadClick(content, fileName) { const link = document.createElement(\"a\"); link.href = URL.createObjectURL(content); link.download = fileName; document.body.appendChild(link); link.click(); document.body.removeChild(link);}","link":"/2017/08/15/%E9%80%9A%E8%BF%87json2csv%E5%89%8D%E7%AB%AF%E5%AF%BC%E5%87%BA/"}],"tags":[{"name":"数组方法","slug":"数组方法","link":"/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"移动项目","slug":"移动项目","link":"/tags/%E7%A7%BB%E5%8A%A8%E9%A1%B9%E7%9B%AE/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Proxy","slug":"Proxy","link":"/tags/Proxy/"},{"name":"defineProperty","slug":"defineProperty","link":"/tags/defineProperty/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Webpack入门","slug":"Webpack入门","link":"/tags/Webpack%E5%85%A5%E9%97%A8/"},{"name":"不是内部命令或外部命令","slug":"不是内部命令或外部命令","link":"/tags/%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4/"},{"name":"不是可运行的程序","slug":"不是可运行的程序","link":"/tags/%E4%B8%8D%E6%98%AF%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F/"},{"name":"Blob","slug":"Blob","link":"/tags/Blob/"},{"name":"文件下载","slug":"文件下载","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"name":"csv表格下载","slug":"csv表格下载","link":"/tags/csv%E8%A1%A8%E6%A0%BC%E4%B8%8B%E8%BD%BD/"},{"name":"图片下载","slug":"图片下载","link":"/tags/%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/"},{"name":"Vue组件通信","slug":"Vue组件通信","link":"/tags/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"session","slug":"session","link":"/tags/session/"}],"categories":[]}