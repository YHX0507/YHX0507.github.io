<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>React基础 | 蜡笔小新Blogs</title>
  <meta name="keywords" content=" react ">
  <meta name="description" content="React基础 | 蜡笔小新Blogs">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="vue3 如何注册全局组件123456789import &amp;#123; createApp &amp;#125; from &amp;#x27;vue&amp;#x27;import App from &amp;#x27;.&#x2F;App.vue&amp;#x27;const app &#x3D; createApp(App)&#x2F;&#x2F; 注册全局组件import SaveButton from &amp;#x27;@&#x2F;globalComponents&#x2F;SaveBut">
<meta property="og:type" content="article">
<meta property="og:title" content="vue3常见问题汇总">
<meta property="og:url" content="http://yoursite.com/2020/11/27/vue3%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="蜡笔小新Blogs">
<meta property="og:description" content="vue3 如何注册全局组件123456789import &amp;#123; createApp &amp;#125; from &amp;#x27;vue&amp;#x27;import App from &amp;#x27;.&#x2F;App.vue&amp;#x27;const app &#x3D; createApp(App)&#x2F;&#x2F; 注册全局组件import SaveButton from &amp;#x27;@&#x2F;globalComponents&#x2F;SaveBut">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-50-21.png">
<meta property="og:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-50-44.png">
<meta property="og:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-51-07.png">
<meta property="og:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-51-35.png">
<meta property="og:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-52-06.png">
<meta property="og:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-52-58.png">
<meta property="og:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-53-28.png">
<meta property="article:published_time" content="2020-11-27T14:44:28.000Z">
<meta property="article:modified_time" content="2020-11-27T15:00:36.128Z">
<meta property="article:author" content="蜡笔小新">
<meta property="article:tag" content="Vue">
<meta property="article:tag" content="Vue3">
<meta property="article:tag" content="Vue3新特性">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yhx0507.github.io/wxapp_static/app/Snipaste_2020-11-27_22-50-21.png">


<link rel="icon" href="/img/avatar3.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 5.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>蜡笔小新</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/YHX0507" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="weibo" href="https://www.weibo.com/3863592977" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-weibo"></use>
                </svg>
            
        </a>
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/00huan-shi-90/activities" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:1183376071@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1183376071&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(19)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color2">cookie</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">session</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Proxy</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">defineProperty</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">Vue</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">移动项目</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">总结</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">Vue组件通信</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">git stash</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">git 版本回退</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Node</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">Express</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">redux</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">react</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">不是内部命令或外部命令</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">不是可运行的程序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">小程序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">面试题</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">数组方法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">图片下载</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">文件下载</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">csv表格下载</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">Webpack</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Webpack入门</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Blob</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Redux</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">React</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Vue3</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">Vue3新特性</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2018/10/11/Cookie%E5%92%8CSession/"
           data-tag="cookie,session"
           data-author="" >
            <span class="post-title" title="Cookie和Session">Cookie和Session</span>
            <span class="post-date" title="2018-10-11 17:23:07">2018/10/11</span>
        </a>
        
        <a  class=""
           href="/2020/07/10/Proxy/"
           data-tag="Proxy,defineProperty"
           data-author="" >
            <span class="post-title" title="Proxy和Object.defineProperty">Proxy和Object.defineProperty</span>
            <span class="post-date" title="2020-07-10 22:01:28">2020/07/10</span>
        </a>
        
        <a  class=""
           href="/2018/03/01/Vue%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"
           data-tag="Vue,移动项目,总结"
           data-author="" >
            <span class="post-title" title="Vue移动端项目总结">Vue移动端项目总结</span>
            <span class="post-date" title="2018-03-01 11:43:25">2018/03/01</span>
        </a>
        
        <a  class=""
           href="/2016/04/13/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"
           data-tag="Vue,Vue组件通信"
           data-author="" >
            <span class="post-title" title="Vue组件通信">Vue组件通信</span>
            <span class="post-date" title="2016-04-13 11:08:34">2016/04/13</span>
        </a>
        
        <a  class=""
           href="/2020/10/30/git%E6%93%8D%E4%BD%9C/"
           data-tag="git,git stash,git 版本回退"
           data-author="" >
            <span class="post-title" title="git操作">git操作</span>
            <span class="post-date" title="2020-10-30 20:59:36">2020/10/30</span>
        </a>
        
        <a  class=""
           href="/2019/09/14/node/"
           data-tag="Node,Express"
           data-author="" >
            <span class="post-title" title="node">node</span>
            <span class="post-date" title="2019-09-14 20:43:25">2019/09/14</span>
        </a>
        
        <a  class=""
           href="/2020/10/30/redux/"
           data-tag="redux,react"
           data-author="" >
            <span class="post-title" title="redux">redux</span>
            <span class="post-date" title="2020-10-30 20:37:10">2020/10/30</span>
        </a>
        
        <a  class=""
           href="/2020/04/04/npm%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"
           data-tag="不是内部命令或外部命令,不是可运行的程序"
           data-author="" >
            <span class="post-title" title="npm全局安装包后无法使用问题解决">npm全局安装包后无法使用问题解决</span>
            <span class="post-date" title="2020-04-04 20:19:36">2020/04/04</span>
        </a>
        
        <a  class=""
           href="/2018/02/27/%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%BB%E7%BB%93/"
           data-tag="小程序"
           data-author="" >
            <span class="post-title" title="关于小程序开发的总结">关于小程序开发的总结</span>
            <span class="post-date" title="2018-02-27 20:56:38">2018/02/27</span>
        </a>
        
        <a  class=""
           href="/2020/11/01/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag="面试题"
           data-author="" >
            <span class="post-title" title="经典面试题">经典面试题</span>
            <span class="post-date" title="2020-11-01 15:20:58">2020/11/01</span>
        </a>
        
        <a  class=""
           href="/2017/12/15/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%8C%E6%8F%A1%E8%BF%99%E4%BA%9B%E5%B0%B1%E5%A4%9F%E4%BA%86/"
           data-tag="数组方法"
           data-author="" >
            <span class="post-title" title="数组常用方法，掌握这些就够了">数组常用方法，掌握这些就够了</span>
            <span class="post-date" title="2017-12-15 21:31:43">2017/12/15</span>
        </a>
        
        <a  class=""
           href="/2020/08/06/%E9%80%9A%E8%BF%87Blob%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/"
           data-tag="图片下载,文件下载"
           data-author="" >
            <span class="post-title" title="通过Blob实现图片下载">通过Blob实现图片下载</span>
            <span class="post-date" title="2020-08-06 20:50:25">2020/08/06</span>
        </a>
        
        <a  class=""
           href="/2017/08/15/%E9%80%9A%E8%BF%87json2csv%E5%89%8D%E7%AB%AF%E5%AF%BC%E5%87%BA/"
           data-tag="文件下载,csv表格下载"
           data-author="" >
            <span class="post-title" title="前端前端导出csv文件（通过json2csv前端导出）">前端前端导出csv文件（通过json2csv前端导出）</span>
            <span class="post-date" title="2017-08-15 20:36:14">2017/08/15</span>
        </a>
        
        <a  class=""
           href="/2019/07/20/Webpack%E5%85%A5%E9%97%A8/"
           data-tag="Webpack,Webpack入门"
           data-author="" >
            <span class="post-title" title="Webpack入门">Webpack入门</span>
            <span class="post-date" title="2019-07-20 20:04:42">2019/07/20</span>
        </a>
        
        <a  class=""
           href="/2010/08/06/%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87Blob%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"
           data-tag="文件下载,Blob"
           data-author="" >
            <span class="post-title" title="前端通过Blob实现文件下载">前端通过Blob实现文件下载</span>
            <span class="post-date" title="2010-08-06 19:59:09">2010/08/06</span>
        </a>
        
        <a  class=""
           href="/2020/11/01/React%E5%9F%BA%E7%A1%80/"
           data-tag="react"
           data-author="" >
            <span class="post-title" title="React基础">React基础</span>
            <span class="post-date" title="2020-11-01 15:30:58">2020/11/01</span>
        </a>
        
        <a  class=""
           href="/2020/11/06/Redux%E9%85%8D%E5%90%88React%E4%BD%BF%E7%94%A8/"
           data-tag="Redux,React"
           data-author="" >
            <span class="post-title" title="Redux配合React使用">Redux配合React使用</span>
            <span class="post-date" title="2020-11-06 21:52:52">2020/11/06</span>
        </a>
        
        <a  class=""
           href="/2020/11/27/Vue3%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag="Vue,Vue3,Vue3新特性"
           data-author="" >
            <span class="post-title" title="Vue3新特性">Vue3新特性</span>
            <span class="post-date" title="2020-11-27 21:39:25">2020/11/27</span>
        </a>
        
        <a  class=""
           href="/2020/11/27/vue3%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag="Vue,Vue3,Vue3新特性"
           data-author="" >
            <span class="post-title" title="vue3常见问题汇总">vue3常见问题汇总</span>
            <span class="post-date" title="2020-11-27 22:44:28">2020/11/27</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-React基础" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">React基础</h1>
    
    <div class="article-meta">
        
        
        
        
        <span class="tag">
            
            <a class="color1">react</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-11-01 15:42:14'>2020-11-01 15:30</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D"><span class="toc-text">课程内容介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E5%9F%BA%E7%A1%80"><span class="toc-text">react基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E4%B8%80%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">学习目标一基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E6%A6%82%E8%BF%B0"><span class="toc-text">React概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFReact"><span class="toc-text">1.1 什么是React</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-React%E7%89%B9%E7%82%B9"><span class="toc-text">1.2 React特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">React的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-React%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">2.1 React的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-HelloWorld"><span class="toc-text">2.2 HelloWorld</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">React脚手架的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-React%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">3.1 React脚手架的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE"><span class="toc-text">3.2 使用脚手架初始化项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%9C%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8React"><span class="toc-text">3.3 在脚手架中使用React</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E4%BA%8C-JSX%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">学习目标二-JSX基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">JSX基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-createElement-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1.1 createElement()的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-JSX%E7%AE%80%E4%BB%8B"><span class="toc-text">1.2 JSX简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-JSX%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.3 JSX使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%9C%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8JSX"><span class="toc-text">1.4 在脚手架中使用JSX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F"><span class="toc-text">1.5 使用注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX%E4%B8%AD%E4%BD%BF%E7%94%A8JS%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">JSX中使用JS表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%B5%8C%E5%85%A5-JS-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.1 嵌入 JS 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F"><span class="toc-text">2.2 使用注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">JSX条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%AF%AD%E6%B3%95"><span class="toc-text">3.1 语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">JSX列表渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E8%AF%AD%E6%B3%95"><span class="toc-text">4.1 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%B3%A8%E6%84%8F"><span class="toc-text">4.2 注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86"><span class="toc-text">JSX样式处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F-style"><span class="toc-text">5.1 行内样式-style</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%B1%BB%E5%90%8D-className-%E6%8E%A8%E8%8D%90"><span class="toc-text">5.2 类名-className(推荐)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E4%B8%89-%E7%BB%84%E4%BB%B6%E7%94%A8%E6%B3%95"><span class="toc-text">学习目标三-组件用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">React 组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-react%E7%BB%84%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.1 react组件的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">React 组件的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6"><span class="toc-text">2.1 使用函数创建组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8class%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6"><span class="toc-text">2.2 使用class创建组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%B0%86%E7%BB%84%E4%BB%B6%E6%8A%BD%E7%A6%BB%E4%B8%BAjs%E6%96%87%E4%BB%B6"><span class="toc-text">2.3 将组件抽离为js文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">React 事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-text">3.1 事件绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.2 事件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-this-%E6%8C%87%E5%90%91"><span class="toc-text">3.3 事件绑定 this 指向</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8bind%E4%BF%AE%E6%94%B9this%E6%8C%87%E5%90%91%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-text">利用bind修改this指向组件实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95-%E6%8E%A8%E8%8D%90"><span class="toc-text">利用箭头函数方法(推荐)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-text">有状态组件和无状态组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.1 有状态组件和无状态组件的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84-state-%E5%92%8C-setState"><span class="toc-text">类组件中的 state 和 setState()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-state%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">5.1 state的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-setState-%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81"><span class="toc-text">5.2 setState()修改状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86"><span class="toc-text">表单处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">6.1 受控组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">6.2 非受控组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0-%E8%AF%84%E8%AE%BA"><span class="toc-text">案例练习-评论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA"><span class="toc-text">效果演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E8%AE%BA%E5%88%97%E8%A1%A8"><span class="toc-text">评论列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E6%97%A0%E8%AF%84%E8%AE%BA"><span class="toc-text">暂无评论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AF%84%E8%AE%BA%E4%BF%A1%E6%81%AF"><span class="toc-text">获取评论信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E8%A1%A8%E8%AF%84%E8%AE%BA"><span class="toc-text">发表评论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86"><span class="toc-text">组件拆分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E5%9B%9B-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E5%92%8C%E5%B0%81%E8%A3%85"><span class="toc-text">学习目标四-组件通讯和封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E4%BB%8B%E7%BB%8D"><span class="toc-text">组件通讯介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF"><span class="toc-text">1.1 什么是组件通讯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84-props"><span class="toc-text">组件的 props</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-props%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 props的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-props%E7%89%B9%E7%82%B9"><span class="toc-text">2.2 props特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">组件通讯的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-text">3.1 父组件传递数据给子组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%BB%99%E7%88%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">3.2 子组件传递数据给父组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6"><span class="toc-text">3.3 兄弟组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context"><span class="toc-text">Context</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Context"><span class="toc-text">4.1 为什么要使用Context</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%AD%A5%E9%AA%A4"><span class="toc-text">4.2 步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Context%E6%B3%A8%E6%84%8F"><span class="toc-text">4.3 Context注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#props-%E6%B7%B1%E5%85%A5"><span class="toc-text">props 深入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-children%E5%B1%9E%E6%80%A7"><span class="toc-text">5.1 children属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-props%E6%A0%A1%E9%AA%8C"><span class="toc-text">5.2 props校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-props%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">5.3 props默认值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">组件的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">6.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">6.2 三个阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%97%B6-%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-text">创建时(挂载阶段)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%97%B6-%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="toc-text">更新时(更新阶段)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E6%97%B6"><span class="toc-text">卸载时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-text">组件封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1 组件复用概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-render-props%E6%A8%A1%E5%BC%8F"><span class="toc-text">7.2 render props模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">7.3 高阶组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E4%BA%94-%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8"><span class="toc-text">学习目标五-路由使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E8%B7%AF%E7%94%B1"><span class="toc-text">React路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%AE%89%E8%A3%85"><span class="toc-text">1.2 安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">路由的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%B8%89%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6"><span class="toc-text">2.1 三种基础组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%EF%BC%88router-components%EF%BC%89"><span class="toc-text">1. 路由组件（router components）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E7%BB%84%E4%BB%B6%EF%BC%88route-matching-components%EF%BC%89"><span class="toc-text">2. 路由匹配组件（route matching components）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6%EF%BC%88navigation-components%EF%BC%89"><span class="toc-text">3. 导航组件（navigation components）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">2.2 基本使用步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%92%8C404%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE"><span class="toc-text">动态路由和404页面配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1"><span class="toc-text">默认路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="toc-text">编程式导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">匹配模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-text">路由扩展知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E5%85%AD-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7"><span class="toc-text">学习目标六-开发技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-setState-%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">1. setState() 的说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">1.1 第一个参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-text">1.1.1 对象语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="toc-text">1.1.2 函数语法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">1.2 第二个参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JSX-%E8%AF%AD%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text">2. JSX 语法的转化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">3. 组件更新机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">4. 组件性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E8%BD%BB%E9%87%8Fstate"><span class="toc-text">4.1 轻量state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93"><span class="toc-text">4.2 减少不必要的重新渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E7%BA%AF%E7%BB%84%E4%BB%B6"><span class="toc-text">4.3 纯组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%99%9A%E6%8B%9F-DOM"><span class="toc-text">5. 虚拟 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Diff%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-text">6. Diff算法说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Diff-%E7%AE%97%E6%B3%95%E6%83%85%E5%86%B5-%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="toc-text">Diff 算法情况 - 元素类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Diff-%E7%AE%97%E6%B3%95%E6%83%85%E5%86%B5-%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">Diff 算法情况- 元素属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Diff-%E7%AE%97%E6%B3%95%E6%83%85%E5%86%B5-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0"><span class="toc-text">Diff 算法情况 - 修改元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#key-%E5%B1%9E%E6%80%A7"><span class="toc-text">key 属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-text">小结</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="课程内容介绍"><a href="#课程内容介绍" class="headerlink" title="课程内容介绍"></a>课程内容介绍</h1><ul>
<li><p>基础</p>
<ul>
<li>基本用法</li>
<li>脚手架</li>
<li>组件化</li>
<li>路由用法</li>
<li>案例练习</li>
</ul>
</li>
<li><p>项目：移动端网站-<code>好客租房</code> </p>
<ul>
<li>技术栈：react + react-router-dom + axios + sass + ant-mobile</li>
<li>项目优化和部署</li>
</ul>
</li>
<li><p>扩展</p>
<ul>
<li>redux：复杂应用状态管理工具 </li>
</ul>
</li>
</ul>
<blockquote>
<p>提示: 类比vue  学习react</p>
</blockquote>
<hr>
<h1 id="react基础"><a href="#react基础" class="headerlink" title="react基础"></a>react基础</h1><img src="https://yhx0507.github.io/wxapp_static/app/react.png" class="">

<hr>
<h2 id="学习目标一基本使用"><a href="#学习目标一基本使用" class="headerlink" title="学习目标一基本使用"></a>学习目标一基本使用</h2><ul>
<li><input disabled="" type="checkbox"> React概述</li>
<li><input disabled="" type="checkbox"> React的基本使用</li>
<li><input disabled="" type="checkbox"> React脚手架的使用</li>
</ul>
<h3 id="React概述"><a href="#React概述" class="headerlink" title="React概述"></a>React概述</h3><h4 id="1-1-什么是React"><a href="#1-1-什么是React" class="headerlink" title="1.1 什么是React"></a>1.1 什么是React</h4><ul>
<li><strong>React 是一个用于构建用户界面的 JavaScript 库。</strong> </li>
<li>用户界面：HTML页面（前端） </li>
<li>React 主要用来写HTML页面，或构建Web应用 </li>
<li>React 仅仅是<strong>视图层（V）</strong>，也就是只负责视图的渲染，而并非提供了 完整的 M 和 C 的功能。 </li>
<li>React 起源于 Facebook 的内部项目，后又用来架设 Instagram 的网站，并于 2013 年5月开源</li>
</ul>
<h4 id="1-2-React特点"><a href="#1-2-React特点" class="headerlink" title="1.2 React特点"></a>1.2 React特点</h4><ol>
<li><p>声明式</p>
<p>你只需要描述 UI（HTML）看起来是什么样，就跟写HTML一样 。</p>
<p>React 负责渲染 UI，并在数据变化时更新 UI 。</p>
<blockquote>
<p>注意: react是用很像js的语言写标签</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React! 动态变化数据：&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于组件</p>
<ul>
<li>组件是 React 最重要的内容 </li>
<li>组件表示页面中的部分内容 </li>
<li>组合、复用多个组件，可以实现完整的页面功能 </li>
</ul>
</li>
<li><p>学习一次 随处使用</p>
<ul>
<li>使用 React 可以开发 Web 应用 </li>
<li>使用 React 可以开发移动端原生应用（react-native） </li>
<li>使用 React 可以开发 VR（虚拟现实）应用（react 360） </li>
</ul>
</li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/reactcan.png" class="">

<p>扩展阅读：<a target="_blank" rel="noopener" href="https://react.docschina.org/">https://react.docschina.org</a></p>
<h3 id="React的基本使用"><a href="#React的基本使用" class="headerlink" title="React的基本使用"></a>React的基本使用</h3><h4 id="2-1-React的安装"><a href="#2-1-React的安装" class="headerlink" title="2.1 React的安装"></a>2.1 React的安装</h4><ul>
<li><p>安装命令：<code> $ npm i react react-dom</code> </p>
</li>
<li><p>react 包是核心，提供创建元素、组件等功能 </p>
</li>
<li><p>react-dom 包提供 DOM 相关功能等 </p>
</li>
</ul>
<h4 id="2-2-HelloWorld"><a href="#2-2-HelloWorld" class="headerlink" title="2.2 HelloWorld"></a>2.2 HelloWorld</h4><ol>
<li><p>引入 react 和 react-dom 两个 js 文件 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 React 元素 </p>
</li>
<li><p>渲染React元素到页面中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> title = React.createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello React&#x27;</span>) </span></span><br><span class="line"><span class="javascript">    ReactDOM.render(title,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>方法说明</code></p>
<pre><code>1. React.createElement() 说明（知道） 

   - 返回值：React元素 
   - 第一个参数：要创建的React元素名称 
   - 第二个参数：该React元素的属性 
   - 第三个及其以后的参数：该React元素的子节点 

2. ReactDOM.render() 说明 

   - 返回值:React元素

   - 第一个参数：要渲染的React元素 
   - 第二个参数：DOM对象，用于指定渲染到页面中的位置 </code></pre>
<h3 id="React脚手架的使用"><a href="#React脚手架的使用" class="headerlink" title="React脚手架的使用"></a>React脚手架的使用</h3><h4 id="3-1-React脚手架的意义"><a href="#3-1-React脚手架的意义" class="headerlink" title="3.1 React脚手架的意义"></a>3.1 React脚手架的意义</h4><ol>
<li>脚手架是开发现代Web 应用的必备。</li>
<li>高效利用 Webpack、Babel、ESLint 等工具辅助项目开发。 </li>
<li>零配置，无需手动配置繁琐的工具即可使用。 </li>
<li>关注业务，而不是工具配置</li>
</ol>
<h4 id="3-2-使用脚手架初始化项目"><a href="#3-2-使用脚手架初始化项目" class="headerlink" title="3.2 使用脚手架初始化项目"></a>3.2 使用脚手架初始化项目</h4><ol>
<li>初始化项目，命令<code>npx create-react-app my-app</code></li>
<li>启动项目，在项目根目录执行命令：npm start </li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/reactsm.png" class="">

<p><code>补充说明</code> -&gt; npx命令介绍</p>
<ul>
<li>npm v5.2.0 引入的一条命令 </li>
<li>目的：提升包内提供的命令行工具的使用体验 </li>
<li>原来：先安装脚手架包，再使用这个包中提供的命令 </li>
<li>现在：无需安装脚手架包，就可以直接使用这个包提供的命令 </li>
</ul>
<h4 id="3-3-在脚手架中使用React"><a href="#3-3-在脚手架中使用React" class="headerlink" title="3.3 在脚手架中使用React"></a>3.3 在脚手架中使用React</h4><ol>
<li><p>导入 react 和 react-dom 两个包。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 React.createElement() 方法创建 react 元素。</p>
</li>
<li><p>调用 ReactDOM.render() 方法渲染 react 元素到页面中。 </p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>React是构建用户界面的JavaScript库 </li>
<li>使用 react 时，推荐使用脚手架方式。 </li>
<li>初始化项目命令：npx create-react-app my-app 。 </li>
<li>启动项目命令：npm start。 </li>
<li>React.createElement() 方法用于创建 react 元素（知道）。 </li>
<li>ReactDOM.render() 方法负责渲染 react 元素到页面中。 </li>
</ol>
<hr>
<h2 id="学习目标二-JSX基本用法"><a href="#学习目标二-JSX基本用法" class="headerlink" title="学习目标二-JSX基本用法"></a>学习目标二-JSX基本用法</h2><ul>
<li><input disabled="" type="checkbox"> JSX 的基本使用 </li>
<li><input disabled="" type="checkbox"> JSX 中使用 JavaScript 表达式 </li>
<li><input disabled="" type="checkbox"> JSX 的条件渲染 </li>
<li><input disabled="" type="checkbox"> JSX 的列表渲染 </li>
<li><input disabled="" type="checkbox"> JSX 的样式处理 </li>
</ul>
<h3 id="JSX基本使用"><a href="#JSX基本使用" class="headerlink" title="JSX基本使用"></a>JSX基本使用</h3><h4 id="1-1-createElement-的问题"><a href="#1-1-createElement-的问题" class="headerlink" title="1.1 createElement()的问题"></a>1.1 createElement()的问题</h4><ol>
<li>繁琐不简洁。 </li>
<li>不直观，无法一眼看出所描述的结构。 </li>
<li>不优雅，用户体验不爽。 </li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/createEle.png" class="">

<h4 id="1-2-JSX简介"><a href="#1-2-JSX简介" class="headerlink" title="1.2 JSX简介"></a>1.2 JSX简介</h4><ul>
<li>JSX 是 JavaScript XML 的简写，表示在 JavaScript 代码中写 XML（HTML） 格式的代码。 </li>
<li>优势：声明式语法更加直观、与HTML结构相同，降低了学习成本、提升开发效率 </li>
<li>JSX 是 React 的核心内容。 </li>
</ul>
<h4 id="1-3-JSX使用步骤"><a href="#1-3-JSX使用步骤" class="headerlink" title="1.3 JSX使用步骤"></a>1.3 JSX使用步骤</h4><ol>
<li><p>使用 JSX 语法创建 react 元素 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 JSX 语法，创建 react 元素： </span></span><br><span class="line"><span class="keyword">const</span> title = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello JSX<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 ReactDOM.render() 方法渲染 react 元素到页面中 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染创建好的React元素 </span></span><br><span class="line">ReactDOM.render(title, root) </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="1-4-在脚手架中使用JSX"><a href="#1-4-在脚手架中使用JSX" class="headerlink" title="1.4 在脚手架中使用JSX"></a>1.4 在脚手架中使用JSX</h4><ol>
<li>JSX 不是标准的 ECMAScript 语法，它是 ECMAScript 的语法扩展。 </li>
<li>需要使用 babel 编译处理后，才能在浏览器环境中使用。 </li>
<li>create-react-app 脚手架中已经默认有该配置，无需手动配置。 </li>
</ol>
<p><code>注意</code>: <strong>JSX是React.createElement方法的语法糖</strong></p>
<h4 id="1-5-使用注意"><a href="#1-5-使用注意" class="headerlink" title="1.5 使用注意"></a>1.5 使用注意</h4><ol>
<li><p>React元素的有些属性名使用小驼峰命名法</p>
<ul>
<li>特殊属性名：class -&gt; className、for -&gt; htmlFor、tabindex -&gt; tabIndex 。 </li>
</ul>
</li>
<li><p>声明的jsx元素，只能有一个根元素。 </p>
</li>
<li><p>推荐：使用小括号包裹 JSX ，从而避免 JS 中的自动插入分号陷阱。 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用小括号包裹 JSX </span></span><br><span class="line"><span class="keyword">const</span> dv = ( </span><br><span class="line">  &lt;div&gt;Helo JSX&lt;/div&gt; </span><br><span class="line">) </span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="JSX中使用JS表达式"><a href="#JSX中使用JS表达式" class="headerlink" title="JSX中使用JS表达式"></a>JSX中使用JS表达式</h3><h4 id="2-1-嵌入-JS-表达式"><a href="#2-1-嵌入-JS-表达式" class="headerlink" title="2.1 嵌入 JS 表达式"></a>2.1 嵌入 JS 表达式</h4><ul>
<li><p>数据存储在JS中 </p>
</li>
<li><p>语法：{ JavaScript表达式 }  </p>
</li>
<li><p>注意：语法中是<strong>单大括号</strong>，不是双大括号！ </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Jack&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> div = ( </span><br><span class="line">  &lt;div&gt;你好，我叫：&#123;name&#125;&lt;/div&gt; </span><br><span class="line">) </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-2-使用注意"><a href="#2-2-使用注意" class="headerlink" title="2.2 使用注意"></a>2.2 使用注意</h4><ul>
<li>单大括号中可以使用任意的 JavaScript 表达式 （值，变量，函数调用，三元运算符，数组(基本类型，jsx)）</li>
<li><strong>JSX 自身也是 JS 表达式</strong> </li>
<li>注意：不能在{}中出现语句和对象（比如：if/for，{a:100} 等） </li>
</ul>
<h3 id="JSX条件渲染"><a href="#JSX条件渲染" class="headerlink" title="JSX条件渲染"></a>JSX条件渲染</h3><h4 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h4><ul>
<li>场景：loading效果 </li>
<li>条件渲染：根据条件渲染特定的 JSX 结构 </li>
<li>可以使用if/else或三元运算符来实现 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/JSXxr.png" class="">

<h3 id="JSX列表渲染"><a href="#JSX列表渲染" class="headerlink" title="JSX列表渲染"></a>JSX列表渲染</h3><h4 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h4><ul>
<li><p>如果要渲染一组数据，应该使用<strong>数组的 map()</strong> 方法 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> songs = [ </span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;野狼disco&#x27;</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;像我这样的人&#x27;</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;桥边姑娘&#x27;</span>&#125;, </span><br><span class="line">] </span><br><span class="line"><span class="keyword">const</span> list = ( </span><br><span class="line">  &lt;ul&gt; </span><br><span class="line">    &#123;songs.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.key&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125; </span><br><span class="line">  &lt;/ul&gt; </span><br><span class="line">) </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-2-注意"><a href="#4-2-注意" class="headerlink" title="4.2 注意"></a>4.2 注意</h4><ul>
<li><p>如果要渲染一组数据，应该使用数组的 map() 方法 </p>
</li>
<li><p>注意：渲染列表时应该添加 key 属性，key 属性的值要保证唯一 </p>
</li>
<li><p>原则：map() 遍历谁，就给谁添加 key 属性 </p>
</li>
<li><p>注意：尽量避免使用索引号作为 key !</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> songs = [ </span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;野狼disco&#x27;</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;像我这样的人&#x27;</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;桥边姑娘&#x27;</span>&#125;, </span><br><span class="line">] </span><br><span class="line"><span class="keyword">const</span> list = ( </span><br><span class="line">  &lt;ul&gt; </span><br><span class="line">    &#123;songs.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125; </span><br><span class="line">  &lt;/ul&gt; </span><br><span class="line">) </span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="JSX样式处理"><a href="#JSX样式处理" class="headerlink" title="JSX样式处理"></a>JSX样式处理</h3><h4 id="5-1-行内样式-style"><a href="#5-1-行内样式-style" class="headerlink" title="5.1 行内样式-style"></a>5.1 行内样式-style</h4><ul>
<li>style属性<code>&#123;&#123;属性:值&#125;&#125;</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&#123;&#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">backgroundColor</span>: <span class="string">&#x27;#eee&#x27;</span> &#125;&#125;&gt; </span><br><span class="line">  JSX的样式处理 </span><br><span class="line">&lt;/h1&gt; </span><br></pre></td></tr></table></figure>



<h4 id="5-2-类名-className-推荐"><a href="#5-2-类名-className-推荐" class="headerlink" title="5.2 类名-className(推荐)"></a>5.2 类名-className(推荐)</h4><ul>
<li>属性名小驼峰命名</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;title&quot;</span>&gt; </span><br><span class="line"> JSX的样式处理 </span><br><span class="line">&lt;/h1&gt; </span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li>JSX 是React 的核心内容。 </li>
<li>JSX 表示在JS代码中写HTML结构，是React声明式的体现。 </li>
<li>使用 JSX 配合嵌入的 JS 表达式、条件渲染、列表渲染，可以描述任意 UI<br>结构。 </li>
<li>推荐使用 className 的方式给JSX添加样式。 </li>
<li>React 完全利用 JS 语言自身的能力来编写UI，而不是造轮子增强 HTML 功<br>能。 </li>
</ol>
<hr>
<h2 id="学习目标三-组件用法"><a href="#学习目标三-组件用法" class="headerlink" title="学习目标三-组件用法"></a>学习目标三-组件用法</h2><ul>
<li><input disabled="" type="checkbox"> React 组件介绍 </li>
<li><input disabled="" type="checkbox"> React 组件的两种创建方式 </li>
<li><input disabled="" type="checkbox"> React 事件处理 </li>
<li><input disabled="" type="checkbox"> 事件回调函数绑定 this 指向 </li>
<li><input disabled="" type="checkbox"> 有状态组件和无状态组件 </li>
<li><input disabled="" type="checkbox"> 组件中的 state 和 setState() </li>
<li><input disabled="" type="checkbox"> 表单处理 </li>
</ul>
<h3 id="React-组件介绍"><a href="#React-组件介绍" class="headerlink" title="React 组件介绍"></a>React 组件介绍</h3><blockquote>
<p>vue组件特点？</p>
</blockquote>
<h4 id="1-1-react组件的特点"><a href="#1-1-react组件的特点" class="headerlink" title="1.1 react组件的特点"></a>1.1 react组件的特点</h4><ul>
<li><p>组件是 React 的一等公民，<strong>使用 React 就是在用组件</strong> </p>
</li>
<li><p>组件表示页面中的部分功能 </p>
</li>
<li><p>组合多个组件实现完整的页面功能 </p>
</li>
<li><p>特点：可复用、独立、可组合 </p>
<img src="https://yhx0507.github.io/wxapp_static/app/zj.png" class="">

</li>
</ul>
<h3 id="React-组件的创建"><a href="#React-组件的创建" class="headerlink" title="React 组件的创建"></a>React 组件的创建</h3><h4 id="2-1-使用函数创建组件"><a href="#2-1-使用函数创建组件" class="headerlink" title="2.1 使用函数创建组件"></a>2.1 使用函数创建组件</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>函数组件：使用 JS 的函数（或箭头函数）创建的组件 <ul>
<li>函数体内要返回元素</li>
</ul>
</li>
<li>渲染函数组件：用函数名作为组件标签名 </li>
</ul>
<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> ( </span><br><span class="line">    &lt;div&gt;这是我的第一个函数组件！&lt;/div&gt; </span><br><span class="line">  ) </span><br><span class="line">&#125; </span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, root) </span><br></pre></td></tr></table></figure>

<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>函数名称必须以大写字母开头，使用大驼峰命名法</li>
<li>函数组件必须有返回值，表示该组件的结构 </li>
<li>组件标签可以单闭合</li>
</ol>
<h4 id="2-2-使用class创建组件"><a href="#2-2-使用class创建组件" class="headerlink" title="2.2 使用class创建组件"></a>2.2 使用class创建组件</h4><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><ul>
<li>类组件：使用 ES6 的 class关键字 创建的组件 </li>
<li>类组件应该继承 React.Component 父类，从而可以使用父类中提供的方法和属性  </li>
</ul>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>类名称也必须以大写字母开头，使用大驼峰命名法  </li>
<li>类组件必须提供 render() 方法 </li>
<li>render() 方法必须有返回值，表示该组件的结构 </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123; </span><br><span class="line">  render() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello Class Component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, root) </span><br></pre></td></tr></table></figure>



<h4 id="2-3-将组件抽离为js文件"><a href="#2-3-将组件抽离为js文件" class="headerlink" title="2.3 将组件抽离为js文件"></a>2.3 将组件抽离为js文件</h4><ul>
<li>思考：项目中的组件多了之后，该如何组织这些组件呢？  </li>
<li>选择一：将所有组件放在同一个JS文件中 </li>
<li>选择二：将每个组件放到单独的JS文件中 </li>
<li>组件作为一个独立的个体，一般都会放到一个单独的 JS 文件中 </li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>创建Hello.js </li>
<li>在 Hello.js 中导入React </li>
<li>创建组件（函数 或 类） </li>
<li>在 Hello.js 中导出该组件 </li>
<li>在 index.js 中导入 Hello 组件 </li>
<li>渲染组件 </li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/clzj.png" class="">

<p>注意：</p>
<ol>
<li>首先引入React核心包</li>
<li>创建组件</li>
<li>导出组件 </li>
</ol>
<h3 id="React-事件处理"><a href="#React-事件处理" class="headerlink" title="React 事件处理"></a>React 事件处理</h3><h4 id="3-1-事件绑定"><a href="#3-1-事件绑定" class="headerlink" title="3.1 事件绑定"></a>3.1 事件绑定</h4><ul>
<li>React 事件绑定语法与 DOM 事件语法相似 </li>
<li>语法：on+事件名称={事件处理程序}，比如：onClick={() =&gt; {}} </li>
<li>注意：React 事件采用小驼峰命名法，比如：onMouseEnter、onFocus </li>
<li>在组件中绑定事件： </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/eb.png" class="">

<h4 id="3-2-事件对象"><a href="#3-2-事件对象" class="headerlink" title="3.2 事件对象"></a>3.2 事件对象</h4><ul>
<li>可以通过事件处理程序的默认参数获取到事件对象 </li>
<li>React 中的事件对象叫做：合成事件（对象） </li>
<li>合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题 </li>
</ul>
<blockquote>
<p>怎么传递实参给事件处理函数？</p>
</blockquote>
 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">  e.preventDefault() </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;事件对象&#x27;</span>, e) </span><br><span class="line">&#125; </span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> onClick=&#123;handleClick&#125;&gt;点我，不会跳转页面&lt;/a&gt; </span><br></pre></td></tr></table></figure>



<h4 id="3-3-事件绑定-this-指向"><a href="#3-3-事件绑定-this-指向" class="headerlink" title="3.3 事件绑定 this 指向"></a>3.3 事件绑定 this 指向</h4><h5 id="利用bind修改this指向组件实例"><a href="#利用bind修改this指向组件实例" class="headerlink" title="利用bind修改this指向组件实例"></a>利用bind修改this指向组件实例</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function.prototype.bind() </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  addNum() &#123;</span><br><span class="line">    <span class="built_in">this</span>.num += <span class="number">1</span>;</span><br><span class="line">    alert(<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 onClick=&#123;<span class="built_in">this</span>.addNum.bind(<span class="built_in">this</span>)&#125;&gt;数字加一&lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="利用箭头函数方法-推荐"><a href="#利用箭头函数方法-推荐" class="headerlink" title="利用箭头函数方法(推荐)"></a>利用箭头函数方法(推荐)</h5><ul>
<li>利用箭头函数定义方法 </li>
<li>注意：该语法是实验性语法，但是，由于babel的存在可以直接使用 </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  addNum = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num += <span class="number">1</span>;</span><br><span class="line">    alert(<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 onClick=&#123;<span class="built_in">this</span>.addNum&#125;&gt;数字加一&lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有状态组件和无状态组件"><a href="#有状态组件和无状态组件" class="headerlink" title="有状态组件和无状态组件"></a>有状态组件和无状态组件</h3><p>Vue =》 script {data(){reutn {key:val}}}</p>
<ul>
<li><p>函数组件-&gt;无状态组件</p>
</li>
<li><p>类组件class-&gt;有状态组件</p>
</li>
</ul>
<h4 id="4-1-有状态组件和无状态组件的区别"><a href="#4-1-有状态组件和无状态组件的区别" class="headerlink" title="4.1 有状态组件和无状态组件的区别"></a>4.1 有状态组件和无状态组件的区别</h4><ul>
<li>函数组件又叫做无状态组件，类组件又叫做有状态组件 </li>
<li>状态（state）即数据，某个时刻的值  </li>
<li>类组件有自己的状态，负责更新 UI，让页面“动” 起来 </li>
<li>函数组件没有自己的状态，只负责数据展示（静）</li>
<li>比如计数器案例中，点击按钮让数值加 1 。0 和 1 就是不同时刻的状态，而由 0 变为 1 就表示状态发生了变 化。状态变化后，UI 也要相应的更新。React 中想要实现该功能，就要使用有状态组件来完成。 </li>
</ul>
<h3 id="类组件中的-state-和-setState"><a href="#类组件中的-state-和-setState" class="headerlink" title="类组件中的 state 和 setState()"></a>类组件中的 state 和 setState()</h3><h4 id="5-1-state的基本使用"><a href="#5-1-state的基本使用" class="headerlink" title="5.1 state的基本使用"></a>5.1 state的基本使用</h4><blockquote>
<p>Vue 组件中data</p>
</blockquote>
<ul>
<li>状态（state）即数据，是组件内部的私有数据，只能在组件内部使用 </li>
<li>state 的值是对象，表示一个组件中可以有多个数据 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/state.png" class="">

<ul>
<li>获取状态：this.state </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/qst.png" class="">

<h4 id="5-2-setState-修改状态"><a href="#5-2-setState-修改状态" class="headerlink" title="5.2 setState()修改状态"></a>5.2 setState()修改状态</h4><ul>
<li>状态是可变的 <ul>
<li>语法：this.setState({ key:val, key2:val2 }) </li>
</ul>
</li>
<li>注意：不要直接修改 state 中的值，这是错误的！！！ -&gt;this.state.num=2这样写不可以!</li>
<li>setState() 作用：<ul>
<li>修改 state </li>
<li>更新UI </li>
</ul>
</li>
<li>思想：数据驱动视图 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/setState.png" class="">

<h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><h4 id="6-1-受控组件"><a href="#6-1-受控组件" class="headerlink" title="6.1 受控组件"></a>6.1 受控组件</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>HTML 中的表单元素是可输入的，也就是有自己的可变状态 </li>
<li>而React 中可变状态通常保存在 state 中，并且只能通过 setState() 方法来修改 </li>
<li>React将 state 与表单元素值value绑定到一起，由 state 的值来控制表单元素的值 </li>
<li>受控组件：其值受到 React 控制的表单元素 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/sk.png" class="">

<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>给表单元素value绑定state状态</li>
<li>在 change 事件处理程序中来修改对应的state </li>
</ol>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      val: <span class="string">&#x27;me&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  changeVal = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 改变状态</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      val: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      	<span class="comment">// 绑定state状态,注册change事件</span></span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;<span class="built_in">this</span>.state.val&#125; onChange=&#123;<span class="built_in">this</span>.changeVal&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>适用场景：获取表单元素数据（双向绑定）</p>
<h4 id="6-2-非受控组件"><a href="#6-2-非受控组件" class="headerlink" title="6.2 非受控组件"></a>6.2 非受控组件</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ul>
<li>说明：借助于 ref，使用原生 DOM 方式来获取表单元素值 </li>
<li>ref 的作用：获取 DOM 或组件实例 </li>
</ul>
<h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li><p>调用 React.createRef() 方法创建一个 ref 对象 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123; </span><br><span class="line">    <span class="built_in">super</span>() </span><br><span class="line">    <span class="built_in">this</span>.txtRef = React.createRef() </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>将创建好的 ref 对象添加到文本框中 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;<span class="built_in">this</span>.txtRef&#125; /&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 ref 对象获取到文本框的值 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.txtRef.current.value) </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li><p>不能在函数<strong>组件上</strong>使用ref，因为它没有实例。</p>
</li>
<li><p>不要过度使用Refs。</p>
</li>
</ul>
<p>适用场景：</p>
<ol>
<li>操作DOM元素</li>
<li>控制元素焦点或媒体播放</li>
</ol>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ol>
<li>组件的两种创建方式：函数组件和类组件 </li>
<li>无状态（函数）组件，负责静态结构展示 </li>
<li>有状态（类）组件，负责更新 UI ，让页面动起来 </li>
<li>绑定事件注意 this 指向问题 </li>
<li>推荐使用<strong>受控组件</strong>来处理表单 -&gt; <strong>受控的input</strong>-&gt;1. value为state数据2.onChange={修改state}</li>
<li>完全利用 JS 语言的能力创建组件，这是 React 的思想 </li>
</ol>
<hr>
<h2 id="案例练习-评论"><a href="#案例练习-评论" class="headerlink" title="案例练习-评论"></a>案例练习-评论</h2><ul>
<li><input disabled="" type="checkbox"> 完成案例效果（使用准备好的结构和样式：<code>02-其它资源/案例-评论-模版</code>）</li>
</ul>
<h3 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h3><img src="https://yhx0507.github.io/wxapp_static/app/anl.png" class="">

<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol>
<li>渲染评论列表 （列表渲染）</li>
<li>无评论数据展示：暂无评论（条件渲染）</li>
<li>获取评论信息，包括评论人和评论内容（受控组件）</li>
<li>发表评论，更新评论列表（setState())</li>
<li>根据功能拆分组件（组件拆分）</li>
</ol>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><h4 id="评论列表"><a href="#评论列表" class="headerlink" title="评论列表"></a>评论列表</h4><ol>
<li>在 state 中初始化评论列表数据 </li>
<li>使用数组的map方法遍历state中的列表数据 </li>
<li>给每个被遍历的li元素添加key属性 </li>
</ol>
<h4 id="暂无评论"><a href="#暂无评论" class="headerlink" title="暂无评论"></a>暂无评论</h4><ol>
<li>判断列表数据的长度是否为0 </li>
<li>如果为0，则渲染暂无评论 </li>
</ol>
<h4 id="获取评论信息"><a href="#获取评论信息" class="headerlink" title="获取评论信息"></a>获取评论信息</h4><ol>
<li>使用受控组件方式处理表单元素 </li>
</ol>
<h4 id="发表评论"><a href="#发表评论" class="headerlink" title="发表评论"></a>发表评论</h4><ol>
<li>给按钮绑定单击事件 </li>
<li>在事件处理程序中，通过state获取评论信息 </li>
<li>将评论信息添加到state中的list数组，并调用 setState() 方法刷新评论列表</li>
<li>边界情况：清空文本框</li>
<li>边界情况：非空判断 </li>
</ol>
<h4 id="组件拆分"><a href="#组件拆分" class="headerlink" title="组件拆分"></a>组件拆分</h4><blockquote>
<p>如何根据功能，简单拆分组件？</p>
</blockquote>
<ol>
<li><p>把评论功能拆分为两个组件</p>
<ul>
<li>发表评论</li>
<li>评论列表</li>
</ul>
</li>
<li><p>简单了解组件通信，把父组件的数据传递给子组件渲染评论列表</p>
</li>
</ol>
<hr>
<h2 id="学习目标四-组件通讯和封装"><a href="#学习目标四-组件通讯和封装" class="headerlink" title="学习目标四-组件通讯和封装"></a>学习目标四-组件通讯和封装</h2><ul>
<li><input disabled="" type="checkbox"> 组件通讯介绍 </li>
<li><input disabled="" type="checkbox"> 组件的 props </li>
<li><input disabled="" type="checkbox"> 组件通讯的三种方式 </li>
<li><input disabled="" type="checkbox"> Context </li>
<li><input disabled="" type="checkbox"> props 深入</li>
<li><input disabled="" type="checkbox"> 类组件的生命周期 </li>
<li><input disabled="" type="checkbox"> render-props和高阶组件 </li>
</ul>
<h3 id="组件通讯介绍"><a href="#组件通讯介绍" class="headerlink" title="组件通讯介绍"></a>组件通讯介绍</h3><h4 id="1-1-什么是组件通讯"><a href="#1-1-什么是组件通讯" class="headerlink" title="1.1 什么是组件通讯"></a>1.1 什么是组件通讯</h4><p>组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能 拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据 。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通。这个过程就是组件通讯。 </p>
<img src="https://yhx0507.github.io/wxapp_static/app/ctx.png" class="">

<h3 id="组件的-props"><a href="#组件的-props" class="headerlink" title="组件的 props"></a>组件的 props</h3><h4 id="2-1-props的介绍"><a href="#2-1-props的介绍" class="headerlink" title="2.1 props的介绍"></a>2.1 props的介绍</h4><ul>
<li>组件是封闭的，要接收外部数据应该通过 props 来实现  </li>
<li>props的作用：接收传递给组件的数据 </li>
<li>传递数据：给组件标签添加属性  </li>
<li>接收数据：函数组件通过参数props接收数据，类组件通过 this.props 接收数据 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/fs.png" class="">

<h4 id="2-2-props特点"><a href="#2-2-props特点" class="headerlink" title="2.2 props特点"></a>2.2 props特点</h4><ol>
<li>可以给组件传递任意类型的数据 </li>
<li>props 是只读的对象，只能读取属性的值，无法修改对象 </li>
<li>注意：使用类组件时，如果写了构造函数，应该将 props 传递给 super()，否则，无法在构造函数中获取到 props！ </li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/propsdm.png" class="">

<h3 id="组件通讯的三种方式"><a href="#组件通讯的三种方式" class="headerlink" title="组件通讯的三种方式"></a>组件通讯的三种方式</h3><h4 id="3-1-父组件传递数据给子组件"><a href="#3-1-父组件传递数据给子组件" class="headerlink" title="3.1 父组件传递数据给子组件"></a>3.1 父组件传递数据给子组件</h4><ol>
<li><p>父组件提供要传递的state数据 </p>
</li>
<li><p>给子组件标签添加属性，值为 state 中的数据 </p>
</li>
<li><p>子组件中通过 props 接收父组件中传递的数据 </p>
<img src="https://yhx0507.github.io/wxapp_static/app/fts.png" class="">

</li>
</ol>
<h4 id="3-2-子组件传递数据给父组件"><a href="#3-2-子组件传递数据给父组件" class="headerlink" title="3.2 子组件传递数据给父组件"></a>3.2 子组件传递数据给父组件</h4><p>思路：利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数。 </p>
<ol>
<li>父组件提供一个回调函数（用于接收数据）</li>
<li>将该函数作为属性的值，传递给子组件 </li>
<li>子组件通过 props 调用回调函数 </li>
<li>将子组件的数据作为参数传递给回调函数 </li>
</ol>
<p><code>父组件</code></p>
<img src="https://yhx0507.github.io/wxapp_static/app/fc.png" class="">

<p><code>子组件</code></p>
<img src="https://yhx0507.github.io/wxapp_static/app/sc.png" class="">

<h4 id="3-3-兄弟组件"><a href="#3-3-兄弟组件" class="headerlink" title="3.3 兄弟组件"></a>3.3 兄弟组件</h4><ul>
<li>将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态 </li>
<li>思想：<strong>状态提升</strong>  : 父-&gt;子A和子B-&gt; 把A和B共同的state放到父组件中维护</li>
<li>公共父组件职责：1. 提供共享状态 2. 提供操作共享状态的方法 </li>
<li>要通讯的子组件只需通过 props 接收状态或操作状态的方法 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/bc.png" class="">

<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="4-1-为什么要使用Context"><a href="#4-1-为什么要使用Context" class="headerlink" title="4.1 为什么要使用Context"></a>4.1 为什么要使用Context</h4><p>思考：App 组件要传递数据给 Child 组件，该如何处理？ </p>
<ul>
<li>更好的姿势：使用 Context </li>
<li>作用：Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/kjtx.png" class="">

<h4 id="4-2-步骤"><a href="#4-2-步骤" class="headerlink" title="4.2 步骤"></a>4.2 步骤</h4><ol>
<li><p>调用 React. createContext() 创建 Provider（提供数据） 和 Consumer（消费数据） 两个组件。 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext() </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Provider 组件作为父节点。 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider&gt; </span><br><span class="line">  &lt;div className=<span class="string">&quot;App&quot;</span>&gt; </span><br><span class="line">    &lt;Child1 /&gt; </span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">&lt;/Provider&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 value 属性，表示要传递的数据。 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider value=<span class="string">&quot;pink&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 Consumer 组件接收数据</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;&#123;<span class="function"><span class="params">data</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>data参数表示接收到的数据：&#123;data&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&lt;/Consumer&gt; </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-3-Context注意"><a href="#4-3-Context注意" class="headerlink" title="4.3 Context注意"></a>4.3 Context注意</h4><ol>
<li>如果两个组件是远方亲戚（比如，嵌套多层）可以使用Context实现组件通讯 </li>
<li>Context提供了两个组件：Provider 和 Consumer </li>
<li>Provider组件：用来提供数据 </li>
<li>Consumer组件：用来消费数据 </li>
</ol>
<h3 id="props-深入"><a href="#props-深入" class="headerlink" title="props 深入"></a>props 深入</h3><h4 id="5-1-children属性"><a href="#5-1-children属性" class="headerlink" title="5.1 children属性"></a>5.1 children属性</h4><ul>
<li>children 属性：表示组件标签的子节点。当组件标签有子节点时，props 就会有该属性 </li>
<li>children 属性与普通的props一样，值可以是任意值（文本、React元素、组件，甚至是函数） </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/children.png" class="">

<h4 id="5-2-props校验"><a href="#5-2-props校验" class="headerlink" title="5.2 props校验"></a>5.2 props校验</h4><ul>
<li>对于组件来说，props 是外来的，无法保证组件使用者传入什么格式的数据 </li>
<li>如果传入的数据格式不对，可能会导致组件内部报错 </li>
<li>关键问题：组件的使用者不知道明确的错误原因 </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明创建的组件Colors </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Colors</span>(<span class="params">props</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> arr = props.colors </span><br><span class="line">  <span class="keyword">const</span> lis = arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>) </span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;lis&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>) </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 小红使用组件Colors&lt;Colors colors=&#123;19&#125; /&gt; </span></span><br></pre></td></tr></table></figure>

<ul>
<li>props 校验：允许在创建组件的时候，就指定 props 的类型、格式等 </li>
<li>作用：捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/propsjy.png" class="">

<p><code>步骤</code></p>
<ol>
<li>安装包 prop-types （yarn add prop-types / npm i props-types）</li>
<li>导入 prop-types 包 </li>
<li>使用组件名.propTypes = {} 来给组件的props添加校验类型</li>
<li>校验类型通过 PropTypes 对象来指定 </li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi, &#123;props.colors&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">App.propTypes = &#123;   </span><br><span class="line">  <span class="comment">// 约定colors属性为array类型   </span></span><br><span class="line">  <span class="comment">// 如果类型不对，则报出明确错误，便于分析错误原因   </span></span><br><span class="line">  colors: PropTypes.array </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意</code></p>
<ol>
<li>常见类型：array、bool、func、number、object、string </li>
<li>React元素类型：element </li>
<li>必填项：isRequired </li>
<li>特定结构的对象：shape({  })  </li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见类型 </span></span><br><span class="line">optionalFunc: PropTypes.func, </span><br><span class="line"><span class="comment">// 必选 </span></span><br><span class="line">requiredFunc: PropTypes.func.isRequired, </span><br><span class="line"><span class="comment">// 特定结构的对象 </span></span><br><span class="line">optionalObjectWithShape: PropTypes.shape(&#123; </span><br><span class="line">  color: PropTypes.string, </span><br><span class="line">  fontSize: PropTypes.number  </span><br><span class="line">&#125;) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-3-props默认值"><a href="#5-3-props默认值" class="headerlink" title="5.3 props默认值"></a>5.3 props默认值</h4><ul>
<li>场景：分页组件 -&gt;  每页显示条数 </li>
<li>作用：给 props 设置默认值，在未传入 props 时生效 </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> ( </span><br><span class="line">    &lt;div&gt; </span><br><span class="line">      此处展示props的默认值：&#123;props.pageSize&#125; </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">  ) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置默认值 </span></span><br><span class="line">App.defaultProps = &#123; </span><br><span class="line">  pageSize: <span class="number">10</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 不传入pageSize属性 &lt;App /&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><ul>
<li>意义：组件的生命周期有助于理解组件的运行方式、完成更复杂的组件功能和分析组件错误原因等 </li>
<li>组件的生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程 </li>
<li>生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数。 </li>
<li>钩子函数的作用：为开发人员在不同阶段操作组件提供了时机。 </li>
<li>只有 <strong>类组件</strong> 才有生命周期。 </li>
</ul>
<h4 id="6-2-三个阶段"><a href="#6-2-三个阶段" class="headerlink" title="6.2 三个阶段"></a>6.2 三个阶段</h4><ol>
<li>每个阶段的执行时机 </li>
<li>每个阶段钩子函数的执行顺序 </li>
<li>每个阶段钩子函数的作用 </li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/sjd.png" class="">

<h5 id="创建时-挂载阶段"><a href="#创建时-挂载阶段" class="headerlink" title="创建时(挂载阶段)"></a>创建时(挂载阶段)</h5><ul>
<li>执行时机:组件创建时(页面加载时)</li>
<li>执行顺序</li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/gz.png" class="">

<h5 id="更新时-更新阶段"><a href="#更新时-更新阶段" class="headerlink" title="更新时(更新阶段)"></a>更新时(更新阶段)</h5><ul>
<li>执行时机：<strong>1. setState()  2. forceUpdate()  3. 组件接收到新的props</strong>  </li>
<li>说明：以上三者任意一种变化，组件就会重新渲染 </li>
<li>执行顺序： </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/gx.png" class="">

<h5 id="卸载时"><a href="#卸载时" class="headerlink" title="卸载时"></a>卸载时</h5><ul>
<li>执行时机：组件从页面中消失 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/xz.png" class="">

<h3 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h3><h4 id="7-1-组件复用概述"><a href="#7-1-组件复用概述" class="headerlink" title="7.1 组件复用概述"></a>7.1 组件复用概述</h4><ul>
<li>思考：如果两个组件中的部分功能相似或相同，该如何处理？ </li>
<li>处理方式：<strong>复用相似</strong>的功能 </li>
<li>复用什么？1.  state  2.  操作state的方法 （组件状态逻辑 ） </li>
<li>两种方式：1.  <strong>render props模式</strong>  2.  <strong>高阶组件（HOC）</strong>  </li>
<li>注意：这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式（写法） </li>
</ul>
<h4 id="7-2-render-props模式"><a href="#7-2-render-props模式" class="headerlink" title="7.2 render props模式"></a>7.2 render props模式</h4><blockquote>
<p>复用的是组件的状态和功能，传入的是UI要呈现的效果。</p>
</blockquote>
<ul>
<li>思路：将要复用的state和操作state的方法封装到一个组件中 </li>
<li>问题1：如何渲染任意的UI？  </li>
<li>使用该函数的返回值作为要渲染的UI内容（需要组件内部调用渲染）</li>
<li>问题2：如何拿到该组件中复用的state？  </li>
<li>组件内部调用渲染方法的时候传入实参  </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/render-props.png" class="">

<p><code>步骤</code></p>
<ol>
<li>创建Mouse组件，在组件中提供复用的状态逻辑代码（1. 状态  2. 操作状态的方法） </li>
<li>将要复用的状态作为 props.render(state) 方法的参数，暴露到组件外部 </li>
<li>使用 props.render() 的返回值作为要渲染的内容 </li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/render-propsb.png" class="">

<h4 id="7-3-高阶组件"><a href="#7-3-高阶组件" class="headerlink" title="7.3 高阶组件"></a>7.3 高阶组件</h4><blockquote>
<p>高阶函数(形式上):如果一个<strong>函数</strong>的形参或者返回值也是<strong>函数</strong></p>
</blockquote>
<ul>
<li>高阶组件本质上就是高阶函数。</li>
</ul>
<p>高阶组件：<strong>参数为组件</strong>，返回值为<strong>新组件的函数。</strong></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义高阶组件方法</span></span><br><span class="line"><span class="keyword">const</span> withHoc = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    		state = &#123;</span><br><span class="line">          a:<span class="number">0</span></span><br><span class="line">        &#125;	</span><br><span class="line">   </span><br><span class="line">        add=<span class="function">()=&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            a: ++<span class="built_in">this</span>.state.a</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;div&gt;</span><br><span class="line">                <span class="comment">// 参数是组件</span></span><br><span class="line">                &lt;WrappedComponent a=&#123;<span class="built_in">this</span>.state.a&#125; fn=&#123;<span class="built_in">this</span>.add&#125; /&gt;    </span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>概述</code></p>
<ul>
<li>目的：实现状态逻辑复用 </li>
<li>采用 包装（装饰）模式 ，比如说：手机壳 </li>
<li>手机：获取保护功能 </li>
<li>手机壳 ：提供保护功能 </li>
<li>高阶组件就相当于手机壳，通过包装组件，增强组件功能 </li>
</ul>
<p><code>分析</code></p>
<ul>
<li>高阶组件（HOC，Higher-Order Component）<strong>是一个函数</strong>，接收要包装的组件，返回增强后的组件 </li>
<li>高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过props将复用的状态传递给被包装组件 WrappedComponent </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/HOC.png" class="">

<p><code>步骤</code></p>
<ol>
<li>创建一个函数，名称约定以 with 开头 </li>
<li>指定函数参数，参数应该以大写字母开头（作为要渲染的组件）</li>
<li>在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回 </li>
<li>在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件</li>
<li>调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件,并将其渲染到页面中 </li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withMouse</span>(<span class="params">WrappedComponent</span>) </span>&#123; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MouseHoc</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      x:<span class="number">0</span>,</span><br><span class="line">      y:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// Mouse组件的render方法</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> Mouse </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建组件 </span></span><br><span class="line"><span class="keyword">const</span> MousePosition = withMouse(Position) </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 渲染组件 </span></span><br><span class="line">&lt;MousePosition /&gt; </span><br></pre></td></tr></table></figure>

<p><code>传递props    </code></p>
<ul>
<li>问题：props丢失 </li>
<li>原因：高阶组件没有往下传递props </li>
<li>解决方式：渲染 WrappedComponent 时，将 state 和 this.props 一起传递给组件  </li>
<li>传递方式： </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;WrappedComponent &#123;...this.state&#125; &#123;...this.props&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>组件通讯是构建 React 应用必不可少的一环。 </p>
</li>
<li><p>props 的灵活性让组件更加强大。 </p>
</li>
<li><p>状态提升是React组件的常用模式。 </p>
</li>
<li><p>组件生命周期有助于理解组件的运行过程。 </p>
</li>
<li><p>钩子函数让开发者可以在特定的时机执行某些功能。 </p>
</li>
<li><p>render props模式和高阶组件都可以实现组件状态逻辑复用。 </p>
</li>
</ol>
<hr>
<h2 id="学习目标五-路由使用"><a href="#学习目标五-路由使用" class="headerlink" title="学习目标五-路由使用"></a>学习目标五-路由使用</h2><ul>
<li><input disabled="" type="checkbox"> React路由介绍和安装 </li>
<li><input disabled="" type="checkbox"> 三种路由组件</li>
<li><input disabled="" type="checkbox"> 路由的基本使用</li>
<li><input disabled="" type="checkbox"> 编程式导航 </li>
<li><input disabled="" type="checkbox"> 匹配模式  </li>
<li><input disabled="" type="checkbox"> 路由扩展知识</li>
</ul>
<h3 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h3><h4 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><p>现代的前端应用大多都是 SPA（单页应用程序），也就是只有一个 HTML 页面的应用程序。因为它的用户体 验更好、对服务器的压力更小，所以更受欢迎。为了有效的使用单个页面来管理原来多页面的功能，前端路由 应运而生。 </p>
<ul>
<li>前端路由的功能：让用户从一个视图（页面）导航到另一个视图（页面） </li>
<li>前端路由是一套映射规则，在React中，是 URL路径 与 组件 的对应关系 </li>
<li>使用React路由简单来说，就是配置 路径和组件（配对） </li>
</ul>
<h4 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h4><blockquote>
<p>vue-router</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://react-router.docschina.org/">react-router-dom</a>(路由5版本的包名) </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i react-router-dom </span><br></pre></td></tr></table></figure>



<h3 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h3><h4 id="2-1-三种基础组件"><a href="#2-1-三种基础组件" class="headerlink" title="2.1 三种基础组件"></a>2.1 三种基础组件</h4><h5 id="1-路由组件（router-components）"><a href="#1-路由组件（router-components）" class="headerlink" title="1. 路由组件（router components）"></a>1. 路由组件（router components）</h5><p>​    每个 React Router 应用程序的核心是一个 router 组件。对于 Web 项目，react-router-dom 提供了<code>&lt;BrowserRouter&gt;</code>(<strong>推荐</strong>)和<code>&lt;HashRouter&gt;</code>两种路由组件。</p>
<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;,</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h5 id="2-路由匹配组件（route-matching-components）"><a href="#2-路由匹配组件（route-matching-components）" class="headerlink" title="2. 路由匹配组件（route matching components）"></a>2. 路由匹配组件（route matching components）</h5><p>​    有两个路由匹配组件： <code>&lt;Route&gt;</code> 和 <code>&lt;Switch&gt;</code>。</p>
<ul>
<li>通过<code>&lt;Route&gt;</code>组件的path属性匹配当前地址，当匹配成功时就渲染component属性指定的组件。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 当前路径是&#x27;/about&#x27;</span></span><br><span class="line">&lt;Route path=<span class="string">&#x27;/about&#x27;</span> component=&#123;About&#125;/&gt; <span class="comment">// renders &lt;About/&gt;</span></span><br><span class="line">&lt;Route path=<span class="string">&#x27;/contact&#x27;</span> component=&#123;Contact&#125;/&gt; <span class="comment">// renders null</span></span><br><span class="line">&lt;Route component=&#123;Always&#125;/&gt; <span class="comment">// renders &lt;Always/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可选组件<code>&lt;Switch&gt;</code>会遍历其所有的子 <code>&lt;Route&gt;</code> 元素，并仅渲染与当前地址匹配的第一个元素，例如可以实现没有匹配到路由显示一个404的组件。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前路径是&#x27;/about&#x27;</span></span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/about&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/contact&quot;</span> component=&#123;Contact&#125; /&gt;</span><br><span class="line">  &#123;<span class="comment">/* 当什么都没匹配到，&lt;NoMatch&gt; 组件将会渲染 */</span>&#125;</span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>



<h5 id="3-导航组件（navigation-components）"><a href="#3-导航组件（navigation-components）" class="headerlink" title="3. 导航组件（navigation components）"></a>3. 导航组件（navigation components）</h5><p>有两个主要的导航组件：<code>&lt;Link&gt;</code> 和<code>&lt;NavLink&gt;</code> 。</p>
<ul>
<li>React Router 提供了一个 <code>&lt;Link&gt;</code> 组件来在你的应用程序中创建链接，渲染后为html的<code>&lt;a&gt;</code>标签。    </li>
</ul>
<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span>&gt;Home&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>&lt;NavLink&gt;</code> 是一种特殊类型的<code>&lt;Link&gt;</code>， 当它的 <code>to</code> 属性与当前地址匹配时，可以自动为其添加<code>active</code>的状态。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当路径是 &#x27;/react &#x27;时</span></span><br><span class="line">&lt;NavLink to=<span class="string">&quot;/react&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span>&gt;</span><br><span class="line">  React</span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-基本使用步骤"><a href="#2-2-基本使用步骤" class="headerlink" title="2.2 基本使用步骤"></a>2.2 基本使用步骤</h4><ol>
<li><p>安装：npm i react-router-dom </p>
</li>
<li><p>导入路由的三个核心组件：Router / Route / Link </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Router 组件包裹整个应用（重要） </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;nav className=<span class="string">&quot;menu&quot;</span>&gt;</span><br><span class="line">		<span class="comment">// ... 			</span></span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">		<span class="comment">// ...路由配置</span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Link 组件作为导航菜单（路由入口） </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/home&quot;</span>&gt;首页&lt;/Link&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Route 组件配置路由规则和要展示的组件（路由出口） </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首页组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 路由配置和导航</span></span><br><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;nav className=<span class="string">&quot;menu&quot;</span>&gt;</span><br><span class="line">    &lt;Link to=<span class="string">&quot;/home&quot;</span>&gt;home&lt;/Link&gt;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/home&quot;</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>使用注意</strong>：</p>
<ul>
<li>Router 组件：包裹整个应用，一个 React 应用只需要使用一次 </li>
</ul>
<ul>
<li>Route、Link组件：必须在Router 组件内部</li>
</ul>
<h3 id="动态路由和404页面配置"><a href="#动态路由和404页面配置" class="headerlink" title="动态路由和404页面配置"></a>动态路由和404页面配置</h3><ul>
<li>动态路由在Route组件的path属性中以：<code>&#123;/url/:parameter&#125;</code></li>
</ul>
<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* 动态组件配置 */</span>&#125;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/about/:id&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用Switch组件配置404页面</li>
</ul>
<h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><ul>
<li>问题：现在的路由都是点击导航菜单后展示的，如何在进入页面的时候就展示呢？  </li>
<li>默认路由：表示进入页面时就会匹配的路由 </li>
<li>默认路由path为：/ </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;Home&#125; /&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：使用exact属性开启路由的精确匹配模式</p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><blockquote>
<p>场景：点击登录按钮，登录成功后，通过代码跳转到后台首页，如何实现？  </p>
</blockquote>
<p>编程式导航：通过 JS 代码来实现页面跳转。</p>
<ul>
<li>只有通过Route组件配置后</li>
</ul>
<ol>
<li>通过组件的props的<strong>history属性</strong>获取：</li>
</ol>
<ul>
<li>push(path)：跳转到某个页面，参数 path 表示要跳转的路径 </li>
<li>go(n)： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页） </li>
</ul>
<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line">  handleLogin = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="built_in">this</span>.props.history.push(<span class="string">&#x27;/home&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  render() &#123;...省略其他代码&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>动态路由的参数获取：</li>
</ol>
<p>通过组件的props的<strong>match属性</strong>获取：</p>
<p>match.params：获取动态路由的参数值</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">this</span>.props.match</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><ul>
<li>问题：当 Link组件的 to 属性值为 “/first”时，为什么 默认路由 也被匹配成功？ </li>
<li>默认情况下，React 路由是<strong>模糊匹配模式</strong> </li>
<li>模糊匹配规则：只要 pathname 以 path 开头就会匹配成功 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/mhpp.png" class="">

<ul>
<li>问题：默认路由任何情况下都会展示，如何避免这种问题？ </li>
<li>给 Route 组件添加 exact 属性，让其变为精确匹配模式 </li>
<li>精确匹配：只有当 path 和 pathname 完全匹配时才会展示该路由 </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时，该组件只能匹配 pathname=“/” 这一种情况 </span></span><br><span class="line"><span class="comment">// 推荐：给默认路由添加 exact 属性。 </span></span><br><span class="line">&lt;Route exact path=<span class="string">&quot;/&quot;</span> component=... /&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="路由扩展知识"><a href="#路由扩展知识" class="headerlink" title="路由扩展知识"></a>路由扩展知识</h3><ol>
<li><strong>二级路由</strong>：在匹配到的一级路由组件中使用Link和Route。</li>
</ol>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line">...</span><br><span class="line">&lt;Route path=<span class="string">&quot;/contact&quot;</span> component=&#123;Contact&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级路由页面</span></span><br><span class="line"><span class="keyword">const</span> Fna = <span class="function">()=&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Contact下a页面<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一级路由组件</span></span><br><span class="line"><span class="keyword">const</span> Contact = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;黑马程序员&lt;/h2&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/contact/a&quot;</span>&gt;Contact下a页面&lt;/Link&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/contact/a&quot;</span> component=&#123;Fna&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：二级路由要包含一级路由的路径</p>
<ol start="2">
<li><strong>自定义Route</strong>：为了设置访问限制条件，自定义Route。</li>
</ol>
<p>系统鉴权场景简单示例：</p>
<ul>
<li>自定义Route组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Auth = <span class="function">(<span class="params">&#123; path, component: Component, history &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;auth：&#x27;</span>, history);</span><br><span class="line">  <span class="keyword">let</span> token = sessionStorage.getItem(<span class="string">&#x27;auth&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route path=&#123;path&#125; render=&#123;<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;route：&#x27;</span>, props);</span><br><span class="line">      <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;请登录！&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> /&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125; /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>路由配置</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* &lt;Route path=&quot;/&quot; exact component=&#123;Home&#125; /&gt; */</span>&#125;</span><br><span class="line">&lt;Redirect exact <span class="keyword">from</span>=<span class="string">&quot;/&quot;</span> to=<span class="string">&quot;/home&quot;</span> /&gt;</span><br><span class="line">&#123;<span class="comment">/* 需要鉴权访问 */</span>&#125;</span><br><span class="line">&lt;Auth exact path=<span class="string">&#x27;/home&#x27;</span> component=&#123;Home&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>withRouter</strong>高阶组件：让一个组件的props增加了一些路由属性和方法，history、match、location。</li>
</ol>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> 增强后的组件 = withRouter(要增强的组件)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ol>
<li>React 路由可以有效的管理多个视图（组件）实现 SPA </li>
<li>Router组件包裹整个应用，<strong>只需要使用一次</strong> </li>
<li>Link组件是入口，Route组件是出口 </li>
<li>通过 props.history 实现编程式导航 </li>
<li>默认模糊匹配，添加 exact 变精确匹配 </li>
<li>React 路由的一切都是组件，可以像思考组件一样思考路由 </li>
</ol>
<h2 id="学习目标六-开发技巧"><a href="#学习目标六-开发技巧" class="headerlink" title="学习目标六-开发技巧"></a>学习目标六-开发技巧</h2><ul>
<li><input disabled="" type="checkbox"> setState() 的说明 </li>
<li><input disabled="" type="checkbox"> JSX 语法的转化过程 </li>
<li><input disabled="" type="checkbox"> 组件更新机制 </li>
<li><input disabled="" type="checkbox"> 组件性能优化 </li>
<li><input disabled="" type="checkbox"> 虚拟 DOM 和 Diff 算法 </li>
</ul>
<h3 id="1-setState-的说明"><a href="#1-setState-的说明" class="headerlink" title="1. setState() 的说明"></a>1. setState() 的说明</h3><h4 id="1-1-第一个参数"><a href="#1-1-第一个参数" class="headerlink" title="1.1 第一个参数"></a>1.1 第一个参数</h4><h5 id="1-1-1-对象语法"><a href="#1-1-1-对象语法" class="headerlink" title="1.1.1 对象语法"></a>1.1.1 对象语法</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setState(stateChange[, callback])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>setState() 是<strong>异步</strong>更新数据的 </li>
<li>注意：使用该语法时，后面的 setState() 不要依赖于前面的 setState() ；可以在第二个参数的回调函数中获取更新后的状态</li>
<li>可以多次调用 setState() ，但是react会做批处理和覆盖，且只会触发一次重新渲染 </li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setState(&#123; </span><br><span class="line">  count: <span class="built_in">this</span>.state.count + <span class="number">1</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// 第二次加一</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123; </span><br><span class="line">  count: <span class="built_in">this</span>.state.count + <span class="number">2</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count) <span class="comment">// 0 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-函数语法"><a href="#1-1-2-函数语法" class="headerlink" title="1.1.2 函数语法"></a>1.1.2 函数语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setState(updater[, callback])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>推荐：使用 setState((state, props) =&gt; {}) 语法，支持异步批量更新 </li>
<li>参数state：表示最新的state </li>
<li>参数props：表示最新的props </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    count: state.count + <span class="number">1</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2-第二个参数"><a href="#1-2-第二个参数" class="headerlink" title="1.2 第二个参数"></a>1.2 第二个参数</h4><ul>
<li>场景：在状态更新（页面完成重新渲染）后立即执行某个操作 </li>
<li>语法： setState(updater[, callback])  </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState( </span><br><span class="line">  (state, props) =&gt; &#123;&#125;, </span><br><span class="line">  () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;这个回调函数会在状态更新后立即执行&#x27;</span>)&#125; </span><br><span class="line">) </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-JSX-语法的转化过程"><a href="#2-JSX-语法的转化过程" class="headerlink" title="2. JSX 语法的转化过程"></a>2. JSX 语法的转化过程</h3><ul>
<li>JSX 仅仅是 createElement() 方法的<strong>语法糖</strong>（简化语法） </li>
<li>JSX 语法被 @babel/preset-react 插件编译为 createElement() 方法 </li>
<li>React 元素：是一个对象，用来描述你希望在屏幕上看到的内容 </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/JSXyl.png" class="">

<h3 id="3-组件更新机制"><a href="#3-组件更新机制" class="headerlink" title="3. 组件更新机制"></a>3. 组件更新机制</h3><ul>
<li>setState() 的两个作用： 1. 修改 state 2. 更新组件（UI） </li>
<li>过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件） </li>
</ul>
<img src="https://yhx0507.github.io/wxapp_static/app/setStateyl.png" class="">

<h3 id="4-组件性能优化"><a href="#4-组件性能优化" class="headerlink" title="4. 组件性能优化"></a>4. 组件性能优化</h3><blockquote>
<p>Vue的data定义什么数据：定义与UI相关的数据</p>
</blockquote>
<h4 id="4-1-轻量state"><a href="#4-1-轻量state" class="headerlink" title="4.1 轻量state"></a>4.1 轻量state</h4><ul>
<li>轻量 state：只存储跟组件渲染相关的数据（比如：count / 列表数据 / loading 等） </li>
<li>注意：不用做渲染的数据不要放在 state 中，比如定时器 id等 </li>
<li>对于这种需要在多个方法中用到的数据，应该放在 this 中 </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;   </span><br><span class="line">  componentDidMount() &#123;     </span><br><span class="line">    <span class="comment">// timerId存储到this中，而不是state中     </span></span><br><span class="line">    <span class="built_in">this</span>.timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="number">2000</span>)   </span><br><span class="line">  &#125;  </span><br><span class="line">  componentWillUnmount() &#123; </span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerId) </span><br><span class="line">  &#125;   </span><br><span class="line">  render() &#123; … &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-2-减少不必要的重新渲染"><a href="#4-2-减少不必要的重新渲染" class="headerlink" title="4.2 减少不必要的重新渲染"></a>4.2 减少不必要的重新渲染</h4><ul>
<li>组件更新机制：父组件更新会引起子组件也被更新</li>
<li>问题：子组件没有任何变化时也会重新渲染 </li>
<li>如何避免不必要的重新渲染呢？ </li>
<li>解决方式：使用钩子函数 <strong>shouldComponentUpdate(nextProps, nextState)</strong> </li>
<li>作用：通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染 </li>
<li>触发时机：更新阶段的钩子函数，组件重新渲染前执行 （shouldComponentUpdate -&gt; render） </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 根据条件，决定是否重新渲染组件</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;       </span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; </span><br><span class="line">  render() &#123;…&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-3-纯组件"><a href="#4-3-纯组件" class="headerlink" title="4.3 纯组件"></a>4.3 纯组件</h4><ul>
<li>纯组件：PureComponent  与 React.Component 功能相似 </li>
<li>区别：PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较 <ul>
<li>原理：纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件 </li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;   </span><br><span class="line">  render() &#123; </span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">      &lt;div&gt;纯组件&lt;/div&gt;     </span><br><span class="line">    )   </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p><code>值类型</code></p>
<ul>
<li>对于值类型来说：比较两个值是否相同（直接赋值即可，没有坑） </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  updateValue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// PureComponent内部比较</span></span><br><span class="line">  count !== <span class="built_in">this</span>.state.count</span><br><span class="line">  <span class="comment">// 执行渲染</span></span><br><span class="line">...  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>引用类型</code> </p>
<ul>
<li>问题：对于引用类型来说：<strong>只比较对象的引用（地址）是否相同</strong> </li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  state = &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">      b: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  updateObj = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    <span class="built_in">this</span>.state.obj.a = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 无法更新视图</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      obj: <span class="built_in">this</span>.state.obj</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>解决办法：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据！（示例）<ul>
<li>说明：纯组件内部的对比是 shallow compare（浅层对比） </li>
<li>对于引用类型来说：只比较对象的引用（地址）是否相同 </li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 正确！创建新数据 </span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;...state.obj, <span class="attr">number</span>: <span class="number">2</span>&#125; </span><br><span class="line">setState(&#123; <span class="attr">obj</span>: newObj &#125;) </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 正确！创建新数据 </span></span><br><span class="line"><span class="comment">// 不要用数组的push / unshift 等直接修改当前数组的的方法 </span></span><br><span class="line"><span class="comment">// 而应该用 concat 或 slice 等这些返回新数组的方法 </span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123; </span><br><span class="line">  list: [...this.state.list, &#123;新数据&#125;] </span><br><span class="line">&#125;) </span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-虚拟-DOM"><a href="#5-虚拟-DOM" class="headerlink" title="5. 虚拟 DOM"></a>5. 虚拟 DOM</h3><ul>
<li>React 更新视图的思想是：<strong>只要 state 变化就重新渲染视图</strong> </li>
<li>问题：组件中只有一个 DOM 元素需要更新时，也得把整个组件的内容重新渲染到页面中？</li>
<li>理想状态：部分更新，只更新变化的地方。 </li>
<li>问题：React 是如何做到部分更新的？ </li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>React.createElement方法创建</p>
</blockquote>
<ul>
<li>虚拟 DOM：本质上就是一个 <strong>JS 对象</strong>，用来描述你希望在屏幕上看到的内容（UI）。 </li>
<li>在数据和真实 DOM 之间<strong>建立了一层缓冲区</strong>。</li>
</ul>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ol>
<li>初次渲染时，React 会根据初始state（Model）结合jsx元素结构，创建一个虚拟 DOM 对象（树）。 </li>
<li>根据虚拟 DOM 生成真正的 DOM，渲染到页面中。 </li>
<li>当数据<strong>变化后</strong>（setState()），重新根据新的数据，<strong>创建新的虚拟DOM对象</strong>（树）。 </li>
<li>与上一次得到的虚拟 DOM 对象，使用 <strong>Diff 算法</strong> 对比（找不同），得到需要更新的内容。 </li>
<li>最终，React 只将变化的内容更新（<strong>patch</strong>）到 DOM 中，重新渲染到页面。 </li>
</ol>
<img src="https://yhx0507.github.io/wxapp_static/app/xnDOM.png" class="">

<h3 id="6-Diff算法说明"><a href="#6-Diff算法说明" class="headerlink" title="6. Diff算法说明"></a>6. Diff算法说明</h3><h4 id="Diff-算法情况-元素类型"><a href="#Diff-算法情况-元素类型" class="headerlink" title="Diff 算法情况 - 元素类型"></a>Diff 算法情况 - 元素类型</h4><ul>
<li>如果两棵树的根元素类型不同，React 会销毁旧树，创建新树</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧树</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新树</span></span><br><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">执行过程：destory all -&gt; insert <span class="keyword">new</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Diff-算法情况-元素属性"><a href="#Diff-算法情况-元素属性" class="headerlink" title="Diff 算法情况- 元素属性"></a>Diff 算法情况- 元素属性</h4><ul>
<li>对于类型相同的 React DOM 元素，React 会对比两者的属性是否相同，只更新不同的属性</li>
<li>当处理完这个 DOM 节点，React 就会递归处理子节点。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;div className=<span class="string">&quot;before&quot;</span> title=<span class="string">&quot;stuff&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">&lt;div className=<span class="string">&quot;after&quot;</span> title=<span class="string">&quot;stuff&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">只更新：className 属性值</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span>&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span>&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">只更新：color 属性值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Diff-算法情况-修改元素"><a href="#Diff-算法情况-修改元素" class="headerlink" title="Diff 算法情况 - 修改元素"></a>Diff 算法情况 - 修改元素</h4><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><ul>
<li>1 当在子节点的后面添加一个节点，这时候两棵树的转化工作执行的很好</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">执行过程：</span><br><span class="line">React会匹配新旧两个&lt;li&gt;first&lt;<span class="regexp">/li&gt;，匹配两个&lt;li&gt;second&lt;/</span>li&gt;，然后添加 &lt;li&gt;third&lt;/li&gt; tree</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2 但是如果你在开始位置插入一个元素，那么问题就来了：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt; /</span><span class="regexp">/ 一次  1-&gt;3</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;1&lt;/</span>li&gt; <span class="comment">// 一次  2-&gt;1</span></span><br><span class="line">  &lt;li&gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt; /</span><span class="regexp">/ 新增一次</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">执行过程：</span><br><span class="line">React将改变每一个子节点，而非保持 &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt; 和 &lt;li&gt;2&lt;/</span>li&gt; 不变</span><br></pre></td></tr></table></figure>

<h5 id="key-属性"><a href="#key-属性" class="headerlink" title="key 属性"></a>key 属性</h5><blockquote>
<p>为了解决以上问题，React 提供了一个 key 属性。当子节点带有 key 属性，React 会通过 key 来匹配原始树和后来的树。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=<span class="string">&quot;2015&quot;</span>&gt;<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">  &lt;li key=<span class="string">&quot;2016&quot;</span>&gt;<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=<span class="string">&quot;2014&quot;</span>&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt;  /</span><span class="regexp">/ 添加</span></span><br><span class="line"><span class="regexp">  &lt;li key=&quot;2015&quot;&gt;1&lt;/</span>li&gt;  </span><br><span class="line">  &lt;li key=<span class="string">&quot;2016&quot;</span>&gt;<span class="number">2</span>&lt;/li&gt;  </span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">执行过程：</span><br><span class="line">现在 React 知道带有key <span class="string">&#x27;2014&#x27;</span> 的元素是新的，对于 <span class="string">&#x27;2015&#x27;</span> 和 <span class="string">&#x27;2016&#x27;</span> 仅仅移动位置即可</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：key 属性在 React 内部使用，但不会传递给你的组件</li>
<li>推荐：在遍历数据时，推荐在组件中使用 key 属性：<code>&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</code></li>
<li>注意：<strong>key 只需要保持与他的兄弟节点唯一即可，不需要全局唯一</strong></li>
<li>注意：<strong>尽可能的减少数组 index 作为 key，数组中插入元素的等操作时，会使得效率底下</strong></li>
</ul>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><ol>
<li>工作角度：应用第一，原理第二。 </li>
<li>原理有助于更好地理解 React 的自身运行机制。 </li>
<li>setState()<strong>异步</strong>更新数据。 </li>
<li>父组件更新导致子组件更新，纯组件提升性能。 </li>
<li>思路清晰简单为前提，虚拟 DOM 和 Diff 保效率。 </li>
<li>虚拟 DOM -&gt; state + JSX。 </li>
<li>虚拟 DOM 的真正价值从来都不是性能。-&gt; 真正价值是实现跨平台 </li>
</ol>

      
       
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2017 蜡笔小新</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#cookie','#session','#Proxy','#defineProperty','#Vue','#移动项目','#总结','#Vue组件通信','#git','#git stash','#git 版本回退','#Node','#Express','#redux','#react','#不是内部命令或外部命令','#不是可运行的程序','#小程序','#面试题','#数组方法','#图片下载','#文件下载','#csv表格下载','#Webpack','#Webpack入门','#Blob','#Redux','#React','#Vue3','#Vue3新特性',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("/img/article-list-background.jpeg");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
